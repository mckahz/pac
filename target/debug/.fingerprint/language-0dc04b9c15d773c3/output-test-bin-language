{"$message_type":"diagnostic","message":"expected parameter name, found `{`","code":null,"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":84,"byte_end":85,"line_start":7,"line_end":7,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    {expr, location}: source::Expr,","highlight_start":5,"highlight_end":6}],"label":"expected parameter name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected parameter name, found `{`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:7:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    {expr, location}: source::Expr,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected parameter name\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `nom_locate`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":451,"byte_end":461,"line_start":18,"line_end":18,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"use nom_locate::LocatedSpan;","highlight_start":5,"highlight_end":15}],"label":"use of unresolved module or unlinked crate `nom_locate`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `nom_locate`, use `cargo add nom_locate` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `nom_locate`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:18:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_locate::LocatedSpan;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `nom_locate`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `nom_locate`, use `cargo add nom_locate` to add it to your `Cargo.toml`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"missing lifetime specifier","code":{"code":"E0106","explanation":"This error indicates that a lifetime is missing from a type. If it is an error\ninside a function signature, the problem may be with failing to adhere to the\nlifetime elision rules (see below).\n\nErroneous code examples:\n\n```compile_fail,E0106\nstruct Foo1 { x: &bool }\n              // ^ expected lifetime parameter\nstruct Foo2<'a> { x: &'a bool } // correct\n\nstruct Bar1 { x: Foo2 }\n              // ^^^^ expected lifetime parameter\nstruct Bar2<'a> { x: Foo2<'a> } // correct\n\nenum Baz1 { A(u8), B(&bool), }\n                  // ^ expected lifetime parameter\nenum Baz2<'a> { A(u8), B(&'a bool), } // correct\n\ntype MyStr1 = &str;\n           // ^ expected lifetime parameter\ntype MyStr2<'a> = &'a str; // correct\n```\n\nLifetime elision is a special, limited kind of inference for lifetimes in\nfunction signatures which allows you to leave out lifetimes in certain cases.\nFor more background on lifetime elision see [the book][book-le].\n\nThe lifetime elision rules require that any function signature with an elided\noutput lifetime must either have:\n\n - exactly one input lifetime\n - or, multiple input lifetimes, but the function must also be a method with a\n   `&self` or `&mut self` receiver\n\nIn the first case, the output lifetime is inferred to be the same as the unique\ninput lifetime. In the second case, the lifetime is instead inferred to be the\nsame as the lifetime on `&self` or `&mut self`.\n\nHere are some examples of elision errors:\n\n```compile_fail,E0106\n// error, no input lifetimes\nfn foo() -> &str { }\n\n// error, `x` and `y` have distinct lifetimes inferred\nfn bar(x: &str, y: &str) -> &str { }\n\n// error, `y`'s lifetime is inferred to be distinct from `x`'s\nfn baz<'a>(x: &'a str, y: &str) -> &str { }\n```\n\n[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":11101,"byte_end":11107,"line_start":272,"line_end":272,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":") -> core::Module {","highlight_start":12,"highlight_end":18}],"label":"expected named lifetime parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/canonicalize.rs","byte_start":11029,"byte_end":11043,"line_start":270,"line_end":270,"column_start":19,"column_end":33,"is_primary":false,"text":[{"text":"    parse_module: source::Module,","highlight_start":19,"highlight_end":33}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/canonicalize.rs","byte_start":11060,"byte_end":11088,"line_start":271,"line_end":271,"column_start":16,"column_end":44,"is_primary":false,"text":[{"text":"    type_defs: &[(String, source::TypeDef)],","highlight_start":16,"highlight_end":44}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `parse_module` or one of `type_defs`'s 2 lifetimes","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider introducing a named lifetime parameter","code":null,"level":"help","spans":[{"file_name":"src/canonicalize.rs","byte_start":11009,"byte_end":11009,"line_start":269,"line_end":269,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"pub fn canonicalize_module(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/canonicalize.rs","byte_start":11107,"byte_end":11107,"line_start":272,"line_end":272,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":") -> core::Module {","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/canonicalize.rs","byte_start":11043,"byte_end":11043,"line_start":270,"line_end":270,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"    parse_module: source::Module,","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/canonicalize.rs","byte_start":11061,"byte_end":11061,"line_start":271,"line_end":271,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    type_defs: &[(String, source::TypeDef)],","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/canonicalize.rs","byte_start":11086,"byte_end":11086,"line_start":271,"line_end":271,"column_start":42,"column_end":42,"is_primary":true,"text":[{"text":"    type_defs: &[(String, source::TypeDef)],","highlight_start":42,"highlight_end":42}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0106]\u001b[0m\u001b[0m\u001b[1m: missing lifetime specifier\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:272:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    parse_module: source::Module,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m271\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type_defs: &[(String, source::TypeDef)],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m272\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m) -> core::Module {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected named lifetime parameter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `parse_module` or one of `type_defs`'s 2 lifetimes\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0mpub fn canonicalize_module\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    parse_module: source::Module\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m271\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    type_defs: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0m[(String, source::TypeDef\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m)],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m272\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m) -> core::Module\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"missing lifetime specifier","code":{"code":"E0106","explanation":"This error indicates that a lifetime is missing from a type. If it is an error\ninside a function signature, the problem may be with failing to adhere to the\nlifetime elision rules (see below).\n\nErroneous code examples:\n\n```compile_fail,E0106\nstruct Foo1 { x: &bool }\n              // ^ expected lifetime parameter\nstruct Foo2<'a> { x: &'a bool } // correct\n\nstruct Bar1 { x: Foo2 }\n              // ^^^^ expected lifetime parameter\nstruct Bar2<'a> { x: Foo2<'a> } // correct\n\nenum Baz1 { A(u8), B(&bool), }\n                  // ^ expected lifetime parameter\nenum Baz2<'a> { A(u8), B(&'a bool), } // correct\n\ntype MyStr1 = &str;\n           // ^ expected lifetime parameter\ntype MyStr2<'a> = &'a str; // correct\n```\n\nLifetime elision is a special, limited kind of inference for lifetimes in\nfunction signatures which allows you to leave out lifetimes in certain cases.\nFor more background on lifetime elision see [the book][book-le].\n\nThe lifetime elision rules require that any function signature with an elided\noutput lifetime must either have:\n\n - exactly one input lifetime\n - or, multiple input lifetimes, but the function must also be a method with a\n   `&self` or `&mut self` receiver\n\nIn the first case, the output lifetime is inferred to be the same as the unique\ninput lifetime. In the second case, the lifetime is instead inferred to be the\nsame as the lifetime on `&self` or `&mut self`.\n\nHere are some examples of elision errors:\n\n```compile_fail,E0106\n// error, no input lifetimes\nfn foo() -> &str { }\n\n// error, `x` and `y` have distinct lifetimes inferred\nfn bar(x: &str, y: &str) -> &str { }\n\n// error, `y`'s lifetime is inferred to be distinct from `x`'s\nfn baz<'a>(x: &'a str, y: &str) -> &str { }\n```\n\n[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":4011,"byte_end":4015,"line_start":158,"line_end":158,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Option<Expr> {","highlight_start":13,"highlight_end":17}],"label":"expected named lifetime parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3896,"byte_end":3919,"line_start":154,"line_end":154,"column_start":10,"column_end":33,"is_primary":false,"text":[{"text":"    ops: &mut VecDeque<Operator>,","highlight_start":10,"highlight_end":33}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3932,"byte_end":3951,"line_start":155,"line_end":155,"column_start":12,"column_end":31,"is_primary":false,"text":[{"text":"    exprs: &mut VecDeque<Expr>,","highlight_start":12,"highlight_end":31}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3966,"byte_end":3970,"line_start":156,"line_end":156,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"    mut lhs: Expr,","highlight_start":14,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `ops`, one of `exprs`'s 2 lifetimes, or `lhs`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider introducing a named lifetime parameter","code":null,"level":"help","spans":[{"file_name":"src/parse/expression.rs","byte_start":3885,"byte_end":3885,"line_start":153,"line_end":153,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"fn operator_expression_help(","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/parse/expression.rs","byte_start":4015,"byte_end":4015,"line_start":158,"line_end":158,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":") -> Option<Expr> {","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3897,"byte_end":3897,"line_start":154,"line_end":154,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    ops: &mut VecDeque<Operator>,","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3933,"byte_end":3933,"line_start":155,"line_end":155,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"    exprs: &mut VecDeque<Expr>,","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":"'a ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3950,"byte_end":3950,"line_start":155,"line_end":155,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"    exprs: &mut VecDeque<Expr>,","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/parse/expression.rs","byte_start":3970,"byte_end":3970,"line_start":156,"line_end":156,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"    mut lhs: Expr,","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<'a>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0106]\u001b[0m\u001b[0m\u001b[1m: missing lifetime specifier\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:158:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m154\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ops: &mut VecDeque<Operator>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    exprs: &mut VecDeque<Expr>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    mut lhs: Expr,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    min_precedence: usize,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m158\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m) -> Option<Expr> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected named lifetime parameter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `ops`, one of `exprs`'s 2 lifetimes, or `lhs`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0mfn operator_expression_help\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m154\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    ops: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut VecDeque<Operator>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    exprs: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mmut VecDeque<Expr\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    mut lhs: Expr\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     min_precedence: usize,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m158\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m) -> Option<Expr\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"implicit elided lifetime not allowed here","code":{"code":"E0726","explanation":"An argument lifetime was elided in an async function.\n\nErroneous code example:\n\nWhen a struct or a type is bound/declared with a lifetime it is important for\nthe Rust compiler to know, on usage, the lifespan of the type. When the\nlifetime is not explicitly mentioned and the Rust Compiler cannot determine\nthe lifetime of your type, the following error occurs.\n\n```compile_fail,E0726\nuse futures::executor::block_on;\nstruct Content<'a> {\n    title: &'a str,\n    body: &'a str,\n}\nasync fn create(content: Content) { // error: implicit elided\n                                    // lifetime not allowed here\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\nlet content = Content { title: \"Rust\", body: \"is great!\" };\nlet future = create(content);\nblock_on(future);\n```\n\nSpecify desired lifetime of parameter `content` or indicate the anonymous\nlifetime like `content: Content<'_>`. The anonymous lifetime tells the Rust\ncompiler that `content` is only needed until the `create` function is done with\nits execution.\n\nThe `implicit elision` meaning the omission of suggested lifetime that is\n`pub async fn create<'a>(content: Content<'a>) {}` is not allowed here as\nlifetime of the `content` can differ from current context:\n\n```ignore (needs futures dependency)\nasync fn create(content: Content<'_>) { // ok!\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\n```\n\nKnow more about lifetime elision in this [chapter][lifetime-elision] and a\nchapter on lifetimes can be found [here][lifetimes].\n\n[lifetime-elision]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n[lifetimes]: https://doc.rust-lang.org/rust-by-example/scope/lifetime.html\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":215,"byte_end":221,"line_start":12,"line_end":12,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"impl PrettyPrint for Import {","highlight_start":22,"highlight_end":28}],"label":"expected lifetime parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"indicate the anonymous lifetime","code":null,"level":"help","spans":[{"file_name":"src/report/pretty.rs","byte_start":221,"byte_end":221,"line_start":12,"line_end":12,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"impl PrettyPrint for Import {","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0726]\u001b[0m\u001b[0m\u001b[1m: implicit elided lifetime not allowed here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:12:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl PrettyPrint for Import {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected lifetime parameter\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: indicate the anonymous lifetime\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl PrettyPrint for Import\u001b[0m\u001b[0m\u001b[38;5;10m<'_>\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"implicit elided lifetime not allowed here","code":{"code":"E0726","explanation":"An argument lifetime was elided in an async function.\n\nErroneous code example:\n\nWhen a struct or a type is bound/declared with a lifetime it is important for\nthe Rust compiler to know, on usage, the lifespan of the type. When the\nlifetime is not explicitly mentioned and the Rust Compiler cannot determine\nthe lifetime of your type, the following error occurs.\n\n```compile_fail,E0726\nuse futures::executor::block_on;\nstruct Content<'a> {\n    title: &'a str,\n    body: &'a str,\n}\nasync fn create(content: Content) { // error: implicit elided\n                                    // lifetime not allowed here\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\nlet content = Content { title: \"Rust\", body: \"is great!\" };\nlet future = create(content);\nblock_on(future);\n```\n\nSpecify desired lifetime of parameter `content` or indicate the anonymous\nlifetime like `content: Content<'_>`. The anonymous lifetime tells the Rust\ncompiler that `content` is only needed until the `create` function is done with\nits execution.\n\nThe `implicit elision` meaning the omission of suggested lifetime that is\n`pub async fn create<'a>(content: Content<'a>) {}` is not allowed here as\nlifetime of the `content` can differ from current context:\n\n```ignore (needs futures dependency)\nasync fn create(content: Content<'_>) { // ok!\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\n```\n\nKnow more about lifetime elision in this [chapter][lifetime-elision] and a\nchapter on lifetimes can be found [here][lifetimes].\n\n[lifetime-elision]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n[lifetimes]: https://doc.rust-lang.org/rust-by-example/scope/lifetime.html\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":344,"byte_end":348,"line_start":18,"line_end":18,"column_start":22,"column_end":26,"is_primary":true,"text":[{"text":"impl PrettyPrint for Type {","highlight_start":22,"highlight_end":26}],"label":"expected lifetime parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"indicate the anonymous lifetime","code":null,"level":"help","spans":[{"file_name":"src/report/pretty.rs","byte_start":348,"byte_end":348,"line_start":18,"line_end":18,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"impl PrettyPrint for Type {","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0726]\u001b[0m\u001b[0m\u001b[1m: implicit elided lifetime not allowed here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:18:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl PrettyPrint for Type {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected lifetime parameter\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: indicate the anonymous lifetime\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl PrettyPrint for Type\u001b[0m\u001b[0m\u001b[38;5;10m<'_>\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"implicit elided lifetime not allowed here","code":{"code":"E0726","explanation":"An argument lifetime was elided in an async function.\n\nErroneous code example:\n\nWhen a struct or a type is bound/declared with a lifetime it is important for\nthe Rust compiler to know, on usage, the lifespan of the type. When the\nlifetime is not explicitly mentioned and the Rust Compiler cannot determine\nthe lifetime of your type, the following error occurs.\n\n```compile_fail,E0726\nuse futures::executor::block_on;\nstruct Content<'a> {\n    title: &'a str,\n    body: &'a str,\n}\nasync fn create(content: Content) { // error: implicit elided\n                                    // lifetime not allowed here\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\nlet content = Content { title: \"Rust\", body: \"is great!\" };\nlet future = create(content);\nblock_on(future);\n```\n\nSpecify desired lifetime of parameter `content` or indicate the anonymous\nlifetime like `content: Content<'_>`. The anonymous lifetime tells the Rust\ncompiler that `content` is only needed until the `create` function is done with\nits execution.\n\nThe `implicit elision` meaning the omission of suggested lifetime that is\n`pub async fn create<'a>(content: Content<'a>) {}` is not allowed here as\nlifetime of the `content` can differ from current context:\n\n```ignore (needs futures dependency)\nasync fn create(content: Content<'_>) { // ok!\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\n```\n\nKnow more about lifetime elision in this [chapter][lifetime-elision] and a\nchapter on lifetimes can be found [here][lifetimes].\n\n[lifetime-elision]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n[lifetimes]: https://doc.rust-lang.org/rust-by-example/scope/lifetime.html\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":2385,"byte_end":2392,"line_start":86,"line_end":86,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"impl PrettyPrint for Pattern {","highlight_start":22,"highlight_end":29}],"label":"expected lifetime parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"indicate the anonymous lifetime","code":null,"level":"help","spans":[{"file_name":"src/report/pretty.rs","byte_start":2392,"byte_end":2392,"line_start":86,"line_end":86,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"impl PrettyPrint for Pattern {","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0726]\u001b[0m\u001b[0m\u001b[1m: implicit elided lifetime not allowed here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:86:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl PrettyPrint for Pattern {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected lifetime parameter\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: indicate the anonymous lifetime\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl PrettyPrint for Pattern\u001b[0m\u001b[0m\u001b[38;5;10m<'_>\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"implicit elided lifetime not allowed here","code":{"code":"E0726","explanation":"An argument lifetime was elided in an async function.\n\nErroneous code example:\n\nWhen a struct or a type is bound/declared with a lifetime it is important for\nthe Rust compiler to know, on usage, the lifespan of the type. When the\nlifetime is not explicitly mentioned and the Rust Compiler cannot determine\nthe lifetime of your type, the following error occurs.\n\n```compile_fail,E0726\nuse futures::executor::block_on;\nstruct Content<'a> {\n    title: &'a str,\n    body: &'a str,\n}\nasync fn create(content: Content) { // error: implicit elided\n                                    // lifetime not allowed here\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\nlet content = Content { title: \"Rust\", body: \"is great!\" };\nlet future = create(content);\nblock_on(future);\n```\n\nSpecify desired lifetime of parameter `content` or indicate the anonymous\nlifetime like `content: Content<'_>`. The anonymous lifetime tells the Rust\ncompiler that `content` is only needed until the `create` function is done with\nits execution.\n\nThe `implicit elision` meaning the omission of suggested lifetime that is\n`pub async fn create<'a>(content: Content<'a>) {}` is not allowed here as\nlifetime of the `content` can differ from current context:\n\n```ignore (needs futures dependency)\nasync fn create(content: Content<'_>) { // ok!\n    println!(\"title: {}\", content.title);\n    println!(\"body: {}\", content.body);\n}\n```\n\nKnow more about lifetime elision in this [chapter][lifetime-elision] and a\nchapter on lifetimes can be found [here][lifetimes].\n\n[lifetime-elision]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n[lifetimes]: https://doc.rust-lang.org/rust-by-example/scope/lifetime.html\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3294,"byte_end":3298,"line_start":113,"line_end":113,"column_start":22,"column_end":26,"is_primary":true,"text":[{"text":"impl PrettyPrint for Expr {","highlight_start":22,"highlight_end":26}],"label":"expected lifetime parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"indicate the anonymous lifetime","code":null,"level":"help","spans":[{"file_name":"src/report/pretty.rs","byte_start":3298,"byte_end":3298,"line_start":113,"line_end":113,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"impl PrettyPrint for Expr {","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"<'_>","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0726]\u001b[0m\u001b[0m\u001b[1m: implicit elided lifetime not allowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:113:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl PrettyPrint for Expr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected lifetime parameter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: indicate the anonymous lifetime\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl PrettyPrint for Expr\u001b[0m\u001b[0m\u001b[38;5;10m<'_>\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `LocatedSpan` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/ast/mod.rs","byte_start":51,"byte_end":62,"line_start":4,"line_end":4,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"pub type Span<'a> = LocatedSpan<&'a str>;","highlight_start":21,"highlight_end":32}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `LocatedSpan` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ast/mod.rs:4:21\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub type Span<'a> = LocatedSpan<&'a str>;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `parse_expr` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":189,"byte_end":199,"line_start":10,"line_end":10,"column_start":11,"column_end":21,"is_primary":true,"text":[{"text":"    match parse_expr.expr {","highlight_start":11,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `parse_expr` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:10:11\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    match parse_expr.expr {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"enum takes 0 lifetime arguments but 1 lifetime argument was supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/ast/core.rs","byte_start":192,"byte_end":196,"line_start":8,"line_end":8,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"    pub defs: Vec<(Span<'a>, Expr<'a>)>,","highlight_start":30,"highlight_end":34}],"label":"expected 0 lifetime arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"enum defined here, with 0 lifetime parameters","code":null,"level":"note","spans":[{"file_name":"src/ast/core.rs","byte_start":509,"byte_end":513,"line_start":39,"line_end":39,"column_start":10,"column_end":14,"is_primary":true,"text":[{"text":"pub enum Expr {","highlight_start":10,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"src/ast/core.rs","byte_start":196,"byte_end":200,"line_start":8,"line_end":8,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"    pub defs: Vec<(Span<'a>, Expr<'a>)>,","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: enum takes 0 lifetime arguments but 1 lifetime argument was supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ast/core.rs:8:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub defs: Vec<(Span<'a>, Expr<'a>)>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generics\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 lifetime arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: enum defined here, with 0 lifetime parameters\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/ast/core.rs:39:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Expr {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":1103,"byte_end":1110,"line_start":39,"line_end":39,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    lexeme(tag(kw))","highlight_start":12,"highlight_end":19}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:39:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    lexeme(tag(kw))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":1096,"byte_end":1111,"line_start":39,"line_end":39,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    lexeme(tag(kw))","highlight_start":5,"highlight_end":20}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:39:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    lexeme(tag(kw))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":1203,"byte_end":1209,"line_start":43,"line_end":43,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    lexeme(tag(s))","highlight_start":12,"highlight_end":18}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:43:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    lexeme(tag(s))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":1196,"byte_end":1210,"line_start":43,"line_end":43,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"    lexeme(tag(s))","highlight_start":5,"highlight_end":19}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:43:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    lexeme(tag(s))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `External` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":229,"byte_end":237,"line_start":11,"line_end":11,"column_start":23,"column_end":31,"is_primary":true,"text":[{"text":"        source::Expr::External(name) => core::Expr::Extern(name),","highlight_start":23,"highlight_end":31}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `External` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `External` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:11:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::External(name) => core::Expr::Extern(name),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `External` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Let` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":295,"byte_end":298,"line_start":12,"line_end":12,"column_start":23,"column_end":26,"is_primary":true,"text":[{"text":"        source::Expr::Let(pattern, expr, body) => match pattern {","highlight_start":23,"highlight_end":26}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Let` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Let` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:12:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Let(pattern, expr, body) => match pattern {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Let` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Bind` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":636,"byte_end":640,"line_start":19,"line_end":19,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        source::Expr::Bind(pattern, expr, expr1) => todo!(),","highlight_start":23,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Bind` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Bind` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:19:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Bind(pattern, expr, expr1) => todo!(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Bind` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `If` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":697,"byte_end":699,"line_start":20,"line_end":20,"column_start":23,"column_end":25,"is_primary":true,"text":[{"text":"        source::Expr::If(cond, t, f) => core::Expr::If {","highlight_start":23,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `If` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `If` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:20:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::If(cond, t, f) => core::Expr::If {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `If` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Ap` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":987,"byte_end":989,"line_start":25,"line_end":25,"column_start":23,"column_end":25,"is_primary":true,"text":[{"text":"        source::Expr::Ap(expr, expr1) => core::Expr::Ap {","highlight_start":23,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Ap` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Ap` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:25:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Ap(expr, expr1) => core::Expr::Ap {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Ap` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Identifier` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":1202,"byte_end":1212,"line_start":29,"line_end":29,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        source::Expr::Identifier(ident) => core::Expr::Binding(util::to_camel_case(&ident)),","highlight_start":23,"highlight_end":33}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Identifier` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Identifier` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:29:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Identifier(ident) => core::Expr::Binding(util::to_camel_case(&ident)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Identifier` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Lambda` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":1295,"byte_end":1301,"line_start":30,"line_end":30,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        source::Expr::Lambda(pattern, expr) => match pattern {","highlight_start":23,"highlight_end":29}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Lambda` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Lambda` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:30:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Lambda(pattern, expr) => match pattern {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Lambda` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":1768,"byte_end":1787,"line_start":41,"line_end":41,"column_start":9,"column_end":28,"is_primary":true,"text":[{"text":"        source::Expr::BinOp { op, lhs, rhs } => {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `BinOp` implemented for `source::Expr<'_>`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/canonicalize.rs","byte_start":1768,"byte_end":1787,"line_start":41,"line_end":41,"column_start":9,"column_end":28,"is_primary":true,"text":[{"text":"        source::Expr::BinOp { op, lhs, rhs } => {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":"<source::Expr<'_> as Example>::BinOp","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:41:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::BinOp { op, lhs, rhs } => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if there were a trait named `Example` with associated type `BinOp` implemented for `source::Expr<'_>`, you could use the fully-qualified path\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9msource::Expr::BinOp\u001b[0m\u001b[0m { op, lhs, rhs } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10m<source::Expr<'_> as Example>::BinOp\u001b[0m\u001b[0m { op, lhs, rhs } => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `When` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":6183,"byte_end":6187,"line_start":160,"line_end":160,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        source::Expr::When(expr, items) => core::Expr::When {","highlight_start":23,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `When` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `When` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:160:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m160\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::When(expr, items) => core::Expr::When {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `When` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Unit` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8476,"byte_end":8480,"line_start":207,"line_end":207,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        source::Expr::Unit => todo!(),","highlight_start":23,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Unit` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Unit` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:207:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m207\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Unit => todo!(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Unit` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Bool` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8515,"byte_end":8519,"line_start":208,"line_end":208,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        source::Expr::Bool(_) => todo!(),","highlight_start":23,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Bool` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Bool` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:208:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Bool(_) => todo!(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Bool` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Nat` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8557,"byte_end":8560,"line_start":209,"line_end":209,"column_start":23,"column_end":26,"is_primary":true,"text":[{"text":"        source::Expr::Nat(nat) => core::Expr::Num(nat as f64),","highlight_start":23,"highlight_end":26}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Nat` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Nat` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:209:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Nat(nat) => core::Expr::Num(nat as f64),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Nat` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Int` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8620,"byte_end":8623,"line_start":210,"line_end":210,"column_start":23,"column_end":26,"is_primary":true,"text":[{"text":"        source::Expr::Int(int) => core::Expr::Num(int as f64),","highlight_start":23,"highlight_end":26}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Int` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Int` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:210:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Int(int) => core::Expr::Num(int as f64),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Int` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Float` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8683,"byte_end":8688,"line_start":211,"line_end":211,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"        source::Expr::Float(float) => core::Expr::Num(float as f64),","highlight_start":23,"highlight_end":28}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Float` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Float` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:211:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Float(float) => core::Expr::Num(float as f64),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Float` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `String` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8752,"byte_end":8758,"line_start":212,"line_end":212,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        source::Expr::String(string) => core::Expr::String(string),","highlight_start":23,"highlight_end":29}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `String` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `String` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:212:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::String(string) => core::Expr::String(string),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `String` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Record` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8820,"byte_end":8826,"line_start":213,"line_end":213,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        source::Expr::Record(hash_map) => todo!(),","highlight_start":23,"highlight_end":29}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Record` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Record` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:213:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Record(hash_map) => todo!(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Record` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Access` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":8871,"byte_end":8877,"line_start":214,"line_end":214,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        source::Expr::Access(module, member) => core::Expr::ModuleAccess {","highlight_start":23,"highlight_end":29}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Access` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Access` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:214:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Access(module, member) => core::Expr::ModuleAccess {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Access` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `List` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":9013,"byte_end":9017,"line_start":218,"line_end":218,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        source::Expr::List(exprs) => exprs.into_iter().rev().fold(","highlight_start":23,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `List` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `List` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:218:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::List(exprs) => exprs.into_iter().rev().fold(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `List` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Constructor` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":9961,"byte_end":9972,"line_start":241,"line_end":241,"column_start":23,"column_end":34,"is_primary":true,"text":[{"text":"        source::Expr::Constructor(name) => {","highlight_start":23,"highlight_end":34}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Constructor` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Constructor` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:241:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m241\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Constructor(name) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Constructor` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Tuple` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":10142,"byte_end":10147,"line_start":245,"line_end":245,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"        source::Expr::Tuple(exprs) => exprs.into_iter().fold(","highlight_start":23,"highlight_end":28}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Tuple` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Tuple` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:245:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        source::Expr::Tuple(exprs) => exprs.into_iter().fold(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Tuple` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `str` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":11483,"byte_end":11489,"line_start":285,"line_end":285,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"            .map(|export| util::to_camel_case(&export))","highlight_start":19,"highlight_end":25}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `str`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"all function arguments must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `str` cannot be known at compilation time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:285:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map(|export| util::to_camel_case(&export))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sized` is not implemented for `str`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: all function arguments must have a statically known size\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `str` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":11644,"byte_end":11651,"line_start":290,"line_end":290,"column_start":20,"column_end":27,"is_primary":true,"text":[{"text":"            .map(|(binding, body)| {","highlight_start":20,"highlight_end":27}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `str`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"all local variables must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"unsized locals are gated as an unstable feature","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `str` cannot be known at compilation time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:290:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m290\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map(|(binding, body)| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sized` is not implemented for `str`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: all local variables must have a statically known size\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: unsized locals are gated as an unstable feature\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `str` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/canonicalize.rs","byte_start":11643,"byte_end":11658,"line_start":290,"line_end":290,"column_start":19,"column_end":34,"is_primary":true,"text":[{"text":"            .map(|(binding, body)| {","highlight_start":19,"highlight_end":34}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `str`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only the last element of a tuple may have a dynamically sized type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `str` cannot be known at compilation time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/canonicalize.rs:290:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m290\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map(|(binding, body)| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sized` is not implemented for `str`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: only the last element of a tuple may have a dynamically sized type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":244,"byte_end":270,"line_start":11,"line_end":12,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    value_identifier","highlight_start":5,"highlight_end":21},{"text":"        .map(|s| Expr {","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":270,"byte_end":273,"line_start":12,"line_end":12,"column_start":10,"column_end":13,"is_primary":true,"text":[{"text":"        .map(|s| Expr {","highlight_start":10,"highlight_end":13}],"label":"`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:12:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    value_identifier\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map(|s| Expr {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":470,"byte_end":495,"line_start":21,"line_end":22,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    type_identifier","highlight_start":5,"highlight_end":20},{"text":"        .map(|s| Expr::Constructor(s.to_string()))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":495,"byte_end":498,"line_start":22,"line_end":22,"column_start":10,"column_end":13,"is_primary":true,"text":[{"text":"        .map(|s| Expr::Constructor(s.to_string()))","highlight_start":10,"highlight_end":13}],"label":"`fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: `fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:22:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type_identifier\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map(|s| Expr::Constructor(s.to_string()))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Constructor` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":509,"byte_end":520,"line_start":22,"line_end":22,"column_start":24,"column_end":35,"is_primary":true,"text":[{"text":"        .map(|s| Expr::Constructor(s.to_string()))","highlight_start":24,"highlight_end":35}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Constructor` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Constructor` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:22:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map(|s| Expr::Constructor(s.to_string()))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Constructor` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":831,"byte_end":856,"line_start":37,"line_end":37,"column_start":17,"column_end":42,"is_primary":true,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":17,"highlight_end":42}],"label":"the trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":827,"byte_end":830,"line_start":37,"line_end":37,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":13,"highlight_end":16}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `nom` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":13071,"byte_end":13094,"line_start":403,"line_end":403,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait Parser<Input> {","highlight_start":1,"highlight_end":24}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs","byte_start":3655,"byte_end":3675,"line_start":113,"line_end":113,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Choice<T> {","highlight_start":1,"highlight_end":21}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs","byte_start":503,"byte_end":533,"line_start":16,"line_end":16,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub trait ParseError<I>: Sized {","highlight_start":1,"highlight_end":31}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::opt`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":6211,"byte_end":6214,"line_start":216,"line_end":216,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn opt<I: Clone, E: ParseError<I>, F>(","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":6340,"byte_end":6360,"line_start":220,"line_end":220,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `opt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-4347975134196431019.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:37:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mnom\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:403:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Parser<Input> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs:113:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Choice<T> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs:16:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ParseError<I>: Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::opt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:220:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn opt<I: Clone, E: ParseError<I>, F>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m220\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `opt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-4347975134196431019.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":827,"byte_end":857,"line_start":37,"line_end":37,"column_start":13,"column_end":43,"is_primary":true,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":13,"highlight_end":43}],"label":"the trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `nom` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":13071,"byte_end":13094,"line_start":403,"line_end":403,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait Parser<Input> {","highlight_start":1,"highlight_end":24}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs","byte_start":3655,"byte_end":3675,"line_start":113,"line_end":113,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Choice<T> {","highlight_start":1,"highlight_end":21}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs","byte_start":503,"byte_end":533,"line_start":16,"line_end":16,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub trait ParseError<I>: Sized {","highlight_start":1,"highlight_end":31}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::opt`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":6211,"byte_end":6214,"line_start":216,"line_end":216,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn opt<I: Clone, E: ParseError<I>, F>(","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":6340,"byte_end":6360,"line_start":220,"line_end":220,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `opt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-4347975134196431019.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:37:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mnom\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:403:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Parser<Input> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs:113:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Choice<T> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs:16:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ParseError<I>: Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::opt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:220:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn opt<I: Clone, E: ParseError<I>, F>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m220\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `opt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-4347975134196431019.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":858,"byte_end":861,"line_start":37,"line_end":37,"column_start":44,"column_end":47,"is_primary":true,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":44,"highlight_end":47}],"label":"the trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `nom` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":13071,"byte_end":13094,"line_start":403,"line_end":403,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait Parser<Input> {","highlight_start":1,"highlight_end":24}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs","byte_start":3655,"byte_end":3675,"line_start":113,"line_end":113,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Choice<T> {","highlight_start":1,"highlight_end":21}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs","byte_start":503,"byte_end":533,"line_start":16,"line_end":16,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub trait ParseError<I>: Sized {","highlight_start":1,"highlight_end":31}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-8499851762196480466.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:37:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mnom\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:403:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Parser<Input> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs:113:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Choice<T> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs:16:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ParseError<I>: Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-8499851762196480466.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":827,"byte_end":985,"line_start":37,"line_end":41,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":13,"highlight_end":67},{"text":"                Some(\"-\") => -1,","highlight_start":1,"highlight_end":33},{"text":"                Some(\"+\") => 1,","highlight_start":1,"highlight_end":32},{"text":"                _ => 1,","highlight_start":1,"highlight_end":24},{"text":"            }),","highlight_start":1,"highlight_end":15}],"label":"the trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `nom` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":13071,"byte_end":13094,"line_start":403,"line_end":403,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait Parser<Input> {","highlight_start":1,"highlight_end":24}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs","byte_start":3655,"byte_end":3675,"line_start":113,"line_end":113,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Choice<T> {","highlight_start":1,"highlight_end":21}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs","byte_start":503,"byte_end":533,"line_start":16,"line_end":16,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub trait ParseError<I>: Sized {","highlight_start":1,"highlight_end":31}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::opt`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":6211,"byte_end":6214,"line_start":216,"line_end":216,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn opt<I: Clone, E: ParseError<I>, F>(","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":6340,"byte_end":6360,"line_start":220,"line_end":220,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `opt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-4347975134196431019.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Choice<(impl (Fn(_) -> Result<(_, _), ...>) + Clone, ...)>: Parser<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:37:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Some(\"-\") => -1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Some(\"+\") => 1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                _ => 1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|______________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `nom::Parser<_>` is not implemented for `Choice<(impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone, ...)>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mnom\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:403:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Parser<Input> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs:113:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Choice<T> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs:16:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ParseError<I>: Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::opt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:220:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn opt<I: Clone, E: ParseError<I>, F>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m220\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `opt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-4347975134196431019.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1082,"byte_end":1090,"line_start":44,"line_end":44,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"        not(tag(\".\")),","highlight_start":13,"highlight_end":21}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":1078,"byte_end":1081,"line_start":44,"line_end":44,"column_start":9,"column_end":12,"is_primary":false,"text":[{"text":"        not(tag(\".\")),","highlight_start":9,"highlight_end":12}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::not`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15686,"byte_end":15689,"line_start":584,"line_end":584,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15785,"byte_end":15805,"line_start":586,"line_end":586,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `not`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:44:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        not(tag(\".\")),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::not`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:586:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m585\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `not`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1078,"byte_end":1091,"line_start":44,"line_end":44,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"        not(tag(\".\")),","highlight_start":9,"highlight_end":22}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::not`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15686,"byte_end":15689,"line_start":584,"line_end":584,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15785,"byte_end":15805,"line_start":586,"line_end":586,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `not`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:44:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        not(tag(\".\")),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::not`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:586:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m585\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `not`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":787,"byte_end":797,"line_start":35,"line_end":35,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    terminated(","highlight_start":5,"highlight_end":15}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::not`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15686,"byte_end":15689,"line_start":584,"line_end":584,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15785,"byte_end":15805,"line_start":586,"line_end":586,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `not`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:35:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    terminated(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::not`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:586:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m585\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `not`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":787,"byte_end":1098,"line_start":35,"line_end":45,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    terminated(","highlight_start":5,"highlight_end":16},{"text":"        tuple((","highlight_start":1,"highlight_end":16},{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":1,"highlight_end":67},{"text":"                Some(\"-\") => -1,","highlight_start":1,"highlight_end":33},{"text":"                Some(\"+\") => 1,","highlight_start":1,"highlight_end":32},{"text":"                _ => 1,","highlight_start":1,"highlight_end":24},{"text":"            }),","highlight_start":1,"highlight_end":16},{"text":"            digit1.map(|string: Span| string.parse::<i32>().unwrap()),","highlight_start":1,"highlight_end":71},{"text":"        )),","highlight_start":1,"highlight_end":12},{"text":"        not(tag(\".\")),","highlight_start":1,"highlight_end":23},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::combinator::not`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15686,"byte_end":15689,"line_start":584,"line_end":584,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"pub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs","byte_start":15785,"byte_end":15805,"line_start":586,"line_end":586,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `not`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:35:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    terminated(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tuple((\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Some(\"-\") => -1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        not(tag(\".\")),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::combinator::not`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/combinator/mod.rs:586:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn not<I: Clone, E: ParseError<I>, F>(parser: F) -> impl Parser<I, Output = (), Error = E>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m585\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `not`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":836,"byte_end":844,"line_start":37,"line_end":37,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":22,"highlight_end":30}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:37:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":846,"byte_end":854,"line_start":37,"line_end":37,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {","highlight_start":32,"highlight_end":40}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:37:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            opt(alt((tag(\"-\"), tag(\"+\")))).map(|sign| match sign {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1082,"byte_end":1090,"line_start":44,"line_end":44,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"        not(tag(\".\")),","highlight_start":13,"highlight_end":21}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:44:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        not(tag(\".\")),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1248,"byte_end":1257,"line_start":53,"line_end":53,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        tag(\"\\\"\"),","highlight_start":9,"highlight_end":18}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":1230,"byte_end":1238,"line_start":52,"line_end":52,"column_start":5,"column_end":13,"is_primary":false,"text":[{"text":"    preceded(","highlight_start":5,"highlight_end":13}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::sequence::preceded`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1852,"byte_end":1860,"line_start":61,"line_end":61,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn preceded<I, O, E: ParseError<I>, F, G>(","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1971,"byte_end":1991,"line_start":66,"line_end":66,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `preceded`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:53:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    preceded(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tag(\"\\\"\"),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::sequence::preceded`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs:66:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn preceded<I, O, E: ParseError<I>, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `preceded`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1296,"byte_end":1305,"line_start":54,"line_end":54,"column_start":38,"column_end":47,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":38,"highlight_end":47}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":1267,"byte_end":1276,"line_start":54,"line_end":54,"column_start":9,"column_end":18,"is_primary":false,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":9,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::multi::many_till`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":7819,"byte_end":7828,"line_start":251,"line_end":251,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn many_till<I, E, F, G>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":8015,"byte_end":8035,"line_start":258,"line_end":258,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  G: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `many_till`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:54:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::multi::many_till`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs:258:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn many_till<I, E, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  G: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `many_till`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1267,"byte_end":1306,"line_start":54,"line_end":54,"column_start":9,"column_end":48,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":9,"highlight_end":48}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::multi::many_till`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":7819,"byte_end":7828,"line_start":251,"line_end":251,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn many_till<I, E, F, G>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":8015,"byte_end":8035,"line_start":258,"line_end":258,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  G: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `many_till`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:54:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::multi::many_till`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs:258:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn many_till<I, E, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  G: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `many_till`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1307,"byte_end":1310,"line_start":54,"line_end":54,"column_start":49,"column_end":52,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":49,"highlight_end":52}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:54:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1267,"byte_end":1519,"line_start":54,"line_end":61,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":9,"highlight_end":67},{"text":"            chars","highlight_start":1,"highlight_end":18},{"text":"                .into_iter()","highlight_start":1,"highlight_end":29},{"text":"                .map(|c| c.to_string())","highlight_start":1,"highlight_end":40},{"text":"                .collect::<Vec<String>>()","highlight_start":1,"highlight_end":42},{"text":"                .join(\"\")","highlight_start":1,"highlight_end":26},{"text":"                .to_owned()","highlight_start":1,"highlight_end":28},{"text":"        }),","highlight_start":1,"highlight_end":11}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::multi::many_till`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":7819,"byte_end":7828,"line_start":251,"line_end":251,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn many_till<I, E, F, G>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":8015,"byte_end":8035,"line_start":258,"line_end":258,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  G: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `many_till`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:54:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            chars\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .into_iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .map(|c| c.to_string())\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .to_owned()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::multi::many_till`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs:258:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn many_till<I, E, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  G: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `many_till`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Map<impl Parser<_, Output = (..., ...), Error = _>, ...>: Parser<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1267,"byte_end":1519,"line_start":54,"line_end":61,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":9,"highlight_end":67},{"text":"            chars","highlight_start":1,"highlight_end":18},{"text":"                .into_iter()","highlight_start":1,"highlight_end":29},{"text":"                .map(|c| c.to_string())","highlight_start":1,"highlight_end":40},{"text":"                .collect::<Vec<String>>()","highlight_start":1,"highlight_end":42},{"text":"                .join(\"\")","highlight_start":1,"highlight_end":26},{"text":"                .to_owned()","highlight_start":1,"highlight_end":28},{"text":"        }),","highlight_start":1,"highlight_end":11}],"label":"the trait `nom::Parser<_>` is not implemented for `Map<impl Parser<_, Output = (Vec<...>, ...), Error = _>, ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":1230,"byte_end":1238,"line_start":52,"line_end":52,"column_start":5,"column_end":13,"is_primary":false,"text":[{"text":"    preceded(","highlight_start":5,"highlight_end":13}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `nom` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":13071,"byte_end":13094,"line_start":403,"line_end":403,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait Parser<Input> {","highlight_start":1,"highlight_end":24}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":18629,"byte_end":18649,"line_start":580,"line_end":580,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Map<F, G> {","highlight_start":1,"highlight_end":21}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs","byte_start":503,"byte_end":533,"line_start":16,"line_end":16,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub trait ParseError<I>: Sized {","highlight_start":1,"highlight_end":31}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::sequence::preceded`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1852,"byte_end":1860,"line_start":61,"line_end":61,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn preceded<I, O, E: ParseError<I>, F, G>(","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1998,"byte_end":2030,"line_start":67,"line_end":67,"column_start":6,"column_end":38,"is_primary":true,"text":[{"text":"  G: Parser<I, Output = O, Error = E>,","highlight_start":6,"highlight_end":38}],"label":"required by this bound in `preceded`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7183415495263872509.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider removing this method call, as the receiver has type `impl nom::Parser<_, Output = (Vec<<impl FnMut(_) -> std::result::Result<(_, char), nom::Err<_>> as nom::Parser<_>>::Output>, <impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone as nom::Parser<_>>::Output), Error = _>` and `impl nom::Parser<_, Output = (Vec<<impl FnMut(_) -> std::result::Result<(_, char), nom::Err<_>> as nom::Parser<_>>::Output>, <impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone as nom::Parser<_>>::Output), Error = _>: nom::Parser<_>` trivially holds","code":null,"level":"help","spans":[{"file_name":"src/parse/expression.rs","byte_start":1306,"byte_end":1519,"line_start":54,"line_end":61,"column_start":48,"column_end":11,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":48,"highlight_end":67},{"text":"            chars","highlight_start":1,"highlight_end":18},{"text":"                .into_iter()","highlight_start":1,"highlight_end":29},{"text":"                .map(|c| c.to_string())","highlight_start":1,"highlight_end":40},{"text":"                .collect::<Vec<String>>()","highlight_start":1,"highlight_end":42},{"text":"                .join(\"\")","highlight_start":1,"highlight_end":26},{"text":"                .to_owned()","highlight_start":1,"highlight_end":28},{"text":"        }),","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Map<impl Parser<_, Output = (..., ...), Error = _>, ...>: Parser<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:54:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    preceded(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        tag(\"\\\"\"),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            chars\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .into_iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .map(|c| c.to_string())\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .to_owned()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `nom::Parser<_>` is not implemented for `Map<impl Parser<_, Output = (Vec<...>, ...), Error = _>, ...>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mnom\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:403:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Parser<Input> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m580\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Map<F, G> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs:16:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ParseError<I>: Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::sequence::preceded`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs:67:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn preceded<I, O, E: ParseError<I>, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  G: Parser<I, Output = O, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `preceded`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7183415495263872509.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider removing this method call, as the receiver has type `impl nom::Parser<_, Output = (Vec<<impl FnMut(_) -> std::result::Result<(_, char), nom::Err<_>> as nom::Parser<_>>::Output>, <impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone as nom::Parser<_>>::Output), Error = _>` and `impl nom::Parser<_, Output = (Vec<<impl FnMut(_) -> std::result::Result<(_, char), nom::Err<_>> as nom::Parser<_>>::Output>, <impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone as nom::Parser<_>>::Output), Error = _>: nom::Parser<_>` trivially holds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\"))\u001b[0m\u001b[0m\u001b[38;5;9m.map(|(chars, _)| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-             chars\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-                 .into_iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-                 .map(|c| c.to_string())\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-                 .collect::<Vec<String>>()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-                 .join(\"\")\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-                 .to_owned()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m-         })\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1230,"byte_end":1238,"line_start":52,"line_end":52,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    preceded(","highlight_start":5,"highlight_end":13}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::multi::many_till`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":7819,"byte_end":7828,"line_start":251,"line_end":251,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn many_till<I, E, F, G>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs","byte_start":8015,"byte_end":8035,"line_start":258,"line_end":258,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  G: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `many_till`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:52:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    preceded(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::multi::many_till`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/multi/mod.rs:258:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn many_till<I, E, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  G: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `many_till`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Map<impl Parser<_, Output = (..., ...), Error = _>, ...>: Parser<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1230,"byte_end":1526,"line_start":52,"line_end":62,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    preceded(","highlight_start":5,"highlight_end":14},{"text":"        tag(\"\\\"\"),","highlight_start":1,"highlight_end":19},{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":1,"highlight_end":67},{"text":"            chars","highlight_start":1,"highlight_end":18},{"text":"                .into_iter()","highlight_start":1,"highlight_end":29},{"text":"                .map(|c| c.to_string())","highlight_start":1,"highlight_end":40},{"text":"                .collect::<Vec<String>>()","highlight_start":1,"highlight_end":42},{"text":"                .join(\"\")","highlight_start":1,"highlight_end":26},{"text":"                .to_owned()","highlight_start":1,"highlight_end":28},{"text":"        }),","highlight_start":1,"highlight_end":12},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"the trait `nom::Parser<_>` is not implemented for `Map<impl Parser<_, Output = (Vec<...>, ...), Error = _>, ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `nom` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":13071,"byte_end":13094,"line_start":403,"line_end":403,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait Parser<Input> {","highlight_start":1,"highlight_end":24}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":18629,"byte_end":18649,"line_start":580,"line_end":580,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Map<F, G> {","highlight_start":1,"highlight_end":21}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs","byte_start":503,"byte_end":533,"line_start":16,"line_end":16,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub trait ParseError<I>: Sized {","highlight_start":1,"highlight_end":31}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::sequence::preceded`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1852,"byte_end":1860,"line_start":61,"line_end":61,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn preceded<I, O, E: ParseError<I>, F, G>(","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1998,"byte_end":2030,"line_start":67,"line_end":67,"column_start":6,"column_end":38,"is_primary":true,"text":[{"text":"  G: Parser<I, Output = O, Error = E>,","highlight_start":6,"highlight_end":38}],"label":"required by this bound in `preceded`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7183415495263872509.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Map<impl Parser<_, Output = (..., ...), Error = _>, ...>: Parser<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:52:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    preceded(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tag(\"\\\"\"),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            chars\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `nom::Parser<_>` is not implemented for `Map<impl Parser<_, Output = (Vec<...>, ...), Error = _>, ...>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mnom\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:403:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Parser<Input> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m580\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Map<F, G> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/error.rs:16:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ParseError<I>: Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::sequence::preceded`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs:67:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn preceded<I, O, E: ParseError<I>, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  G: Parser<I, Output = O, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `preceded`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7183415495263872509.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1230,"byte_end":1526,"line_start":52,"line_end":62,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    preceded(","highlight_start":5,"highlight_end":14},{"text":"        tag(\"\\\"\"),","highlight_start":1,"highlight_end":19},{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":1,"highlight_end":67},{"text":"            chars","highlight_start":1,"highlight_end":18},{"text":"                .into_iter()","highlight_start":1,"highlight_end":29},{"text":"                .map(|c| c.to_string())","highlight_start":1,"highlight_end":40},{"text":"                .collect::<Vec<String>>()","highlight_start":1,"highlight_end":42},{"text":"                .join(\"\")","highlight_start":1,"highlight_end":26},{"text":"                .to_owned()","highlight_start":1,"highlight_end":28},{"text":"        }),","highlight_start":1,"highlight_end":12},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"expected `nom::Err<_>`, found `nom::internal::Err<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs","byte_start":3981,"byte_end":4019,"line_start":101,"line_end":101,"column_start":1,"column_end":39,"is_primary":true,"text":[{"text":"pub enum Err<Failure, Error = Failure> {","highlight_start":1,"highlight_end":39}],"label":"this is the expected type `nom::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs","byte_start":3882,"byte_end":3897,"line_start":97,"line_end":97,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub enum Err<E> {","highlight_start":1,"highlight_end":16}],"label":"this is the found type `nom::internal::Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":37,"byte_end":40,"line_start":3,"line_end":3,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use nom::{combinator::success, multi::separated_list0};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `nom` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":93,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"use nom_supreme::ParserExt;","highlight_start":5,"highlight_end":16}],"label":"one version of crate `nom` used here, as a dependency of crate `nom_supreme`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom::sequence::preceded`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1852,"byte_end":1860,"line_start":61,"line_end":61,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn preceded<I, O, E: ParseError<I>, F, G>(","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs","byte_start":1971,"byte_end":1991,"line_start":66,"line_end":66,"column_start":6,"column_end":26,"is_primary":true,"text":[{"text":"  F: Parser<I, Error = E>,","highlight_start":6,"highlight_end":26}],"label":"required by this bound in `preceded`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: expected `impl (Fn(_) -> Result<(_, _), Err<_>>) + Clone` to return `Result<(_, _), Err<_>>`, but it returns `Result<(_, _), Err<_>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:52:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    preceded(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tag(\"\\\"\"),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            chars\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `nom::Err<_>`, found `nom::internal::Err<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `nom` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/internal.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<Failure, Error = Failure> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `nom::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-7.1.3/src/internal.rs:97:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Err<E> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `nom::internal::Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/parse/expression.rs:3:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom::{combinator::success, multi::separated_list0};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nom_supreme::ParserExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `nom` used here, as a dependency of crate `nom_supreme`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `impl (Fn(_) -> std::result::Result<(_, _), nom::internal::Err<_>>) + Clone` to implement `nom::Parser<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom::sequence::preceded`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/sequence/mod.rs:66:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn preceded<I, O, E: ParseError<I>, F, G>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  F: Parser<I, Error = E>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `preceded`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for opaque type `impl Parser<_, Output = _, Error = _>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1230,"byte_end":1532,"line_start":52,"line_end":63,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    preceded(","highlight_start":5,"highlight_end":14},{"text":"        tag(\"\\\"\"),","highlight_start":1,"highlight_end":19},{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":1,"highlight_end":67},{"text":"            chars","highlight_start":1,"highlight_end":18},{"text":"                .into_iter()","highlight_start":1,"highlight_end":29},{"text":"                .map(|c| c.to_string())","highlight_start":1,"highlight_end":40},{"text":"                .collect::<Vec<String>>()","highlight_start":1,"highlight_end":42},{"text":"                .join(\"\")","highlight_start":1,"highlight_end":26},{"text":"                .to_owned()","highlight_start":1,"highlight_end":28},{"text":"        }),","highlight_start":1,"highlight_end":12},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .context(\"string literal\")","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":1532,"byte_end":1539,"line_start":63,"line_end":63,"column_start":6,"column_end":13,"is_primary":true,"text":[{"text":"    .context(\"string literal\")","highlight_start":6,"highlight_end":13}],"label":"method cannot be called on `impl Parser<_, Output = _, Error = _>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`impl nom::Parser<_, Output = _, Error = _>: nom::internal::Parser<_, _, _>`\nwhich is required by `impl nom::Parser<_, Output = _, Error = _>: nom_supreme::ParserExt<_, _, _>`\n`&impl nom::Parser<_, Output = _, Error = _>: nom::internal::Parser<_, _, _>`\nwhich is required by `&impl nom::Parser<_, Output = _, Error = _>: nom_supreme::ParserExt<_, _, _>`\n`&mut impl nom::Parser<_, Output = _, Error = _>: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut impl nom::Parser<_, Output = _, Error = _>: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for opaque type `impl Parser<_, Output = _, Error = _>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:63:6\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    preceded(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tag(\"\\\"\"),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            chars\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .context(\"string literal\")\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called on `impl Parser<_, Output = _, Error = _>` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `impl nom::Parser<_, Output = _, Error = _>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `impl nom::Parser<_, Output = _, Error = _>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&impl nom::Parser<_, Output = _, Error = _>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&impl nom::Parser<_, Output = _, Error = _>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut impl nom::Parser<_, Output = _, Error = _>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut impl nom::Parser<_, Output = _, Error = _>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1248,"byte_end":1257,"line_start":53,"line_end":53,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        tag(\"\\\"\"),","highlight_start":9,"highlight_end":18}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:53:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tag(\"\\\"\"),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<&str as InputIter>::Item == u8`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1296,"byte_end":1305,"line_start":54,"line_end":54,"column_start":38,"column_end":47,"is_primary":true,"text":[{"text":"        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {","highlight_start":38,"highlight_end":47}],"label":"expected `u8`, found `char`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required for `{type error}` to implement `nom::traits::Compare<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `nom_supreme::tag::complete::tag`","code":null,"level":"note","spans":[{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3106,"byte_end":3109,"line_start":93,"line_end":93,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs","byte_start":3237,"byte_end":3247,"line_start":96,"line_end":96,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"        I: InputTake + Compare<T>,","highlight_start":24,"highlight_end":34}],"label":"required by this bound in `tag`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0271]\u001b[0m\u001b[0m\u001b[1m: type mismatch resolving `<&str as InputIter>::Item == u8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:54:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        many_till(satisfy(|_| true), tag(\"\\\"\")).map(|(chars, _)| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `char`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `{type error}` to implement `nom::traits::Compare<&str>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `nom_supreme::tag::complete::tag`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-supreme-0.8.0/src/tag.rs:96:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn tag<T, I, E>(tag: T) -> impl Clone + Fn(I) -> IResult<I, I, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        I: InputTake + Compare<T>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `tag`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Record` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":1839,"byte_end":1845,"line_start":76,"line_end":76,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"    .map(|fields| Expr::Record(fields.into_iter().collect::<HashMap<String, Expr>>()))","highlight_start":25,"highlight_end":31}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Record` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Record` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:76:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .map(|fields| Expr::Record(fields.into_iter().collect::<HashMap<String, Expr>>()))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Record` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `List` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2113,"byte_end":2117,"line_start":87,"line_end":87,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"    .map(Expr::List)","highlight_start":16,"highlight_end":20}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `List` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `List` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:87:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .map(Expr::List)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `List` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2235,"byte_end":2245,"line_start":94,"line_end":94,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":"        tuple((type_identifier.terminated(symbol(\".\")), value_identifier))","highlight_start":32,"highlight_end":42}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:94:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        tuple((type_identifier.terminated(symbol(\".\")), value_identifier))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Access` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2321,"byte_end":2327,"line_start":95,"line_end":95,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"            .map(|(module, member)| Expr::Access(module, member)),","highlight_start":43,"highlight_end":49}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Access` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Access` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:95:43\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map(|(module, member)| Expr::Access(module, member)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Access` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, _), Err<...>>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2443,"byte_end":2446,"line_start":99,"line_end":99,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"        lexeme(string_literal).map(Expr::String),","highlight_start":32,"highlight_end":35}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, _), Err<...>>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:99:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(string_literal).map(Expr::String),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `<&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m           which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m           `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m           which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m           `impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `String` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2453,"byte_end":2459,"line_start":99,"line_end":99,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"        lexeme(string_literal).map(Expr::String),","highlight_start":42,"highlight_end":48}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `String` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `String` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:99:42\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(string_literal).map(Expr::String),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `String` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, _), Err<...>>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2482,"byte_end":2485,"line_start":100,"line_end":100,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        lexeme(nat).map(Expr::Nat),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, _), Err<...>>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:100:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(nat).map(Expr::Nat),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Nat` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2492,"byte_end":2495,"line_start":100,"line_end":100,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"        lexeme(nat).map(Expr::Nat),","highlight_start":31,"highlight_end":34}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Nat` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Nat` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:100:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(nat).map(Expr::Nat),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Nat` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, _), Err<...>>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2518,"byte_end":2521,"line_start":101,"line_end":101,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        lexeme(int).map(Expr::Int),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, _), Err<...>>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:101:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(int).map(Expr::Int),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Int` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2528,"byte_end":2531,"line_start":101,"line_end":101,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"        lexeme(int).map(Expr::Int),","highlight_start":31,"highlight_end":34}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Int` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Int` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:101:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(int).map(Expr::Int),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Int` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Float` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2584,"byte_end":2589,"line_start":102,"line_end":102,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"        lexeme(number::complete::float).map(Expr::Float),","highlight_start":51,"highlight_end":56}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Float` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Float` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:102:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lexeme(number::complete::float).map(Expr::Float),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Float` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl nom::Parser<_, Output = _, Error = _>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2837,"byte_end":2853,"line_start":116,"line_end":116,"column_start":9,"column_end":25,"is_primary":false,"text":[{"text":"        success(func)(i)","highlight_start":9,"highlight_end":25}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":2837,"byte_end":2850,"line_start":116,"line_end":116,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"        success(func)(i)","highlight_start":9,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl nom::Parser<_, Output = _, Error = _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:116:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        success(func)(i)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Ap` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":2959,"byte_end":2961,"line_start":120,"line_end":120,"column_start":47,"column_end":49,"is_primary":true,"text":[{"text":"                .fold(func, |func, arg| Expr::Ap(Box::new(func), Box::new(arg))),","highlight_start":47,"highlight_end":49}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Ap` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Ap` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:120:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .fold(func, |func, arg| Expr::Ap(Box::new(func), Box::new(arg))),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Ap` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3112,"byte_end":3115,"line_start":128,"line_end":128,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"<<\").map(|_| Compose),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:128:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"<<\").map(|_| Compose),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3151,"byte_end":3154,"line_start":129,"line_end":129,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\">>\").map(|_| ComposeRev),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:129:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\">>\").map(|_| ComposeRev),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3193,"byte_end":3196,"line_start":130,"line_end":130,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"<|\").map(|_| Pipe),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:130:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m130\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"<|\").map(|_| Pipe),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3229,"byte_end":3232,"line_start":131,"line_end":131,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"|>\").map(|_| PipeRev),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:131:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m131\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"|>\").map(|_| PipeRev),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3268,"byte_end":3271,"line_start":132,"line_end":132,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"||\").map(|_| Or),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:132:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m132\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"||\").map(|_| Or),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3302,"byte_end":3305,"line_start":133,"line_end":133,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"&&\").map(|_| And),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:133:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"&&\").map(|_| And),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3337,"byte_end":3340,"line_start":134,"line_end":134,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"==\").map(|_| Eq),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:134:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"==\").map(|_| Eq),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3371,"byte_end":3374,"line_start":135,"line_end":135,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"!=\").map(|_| Neq),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:135:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"!=\").map(|_| Neq),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3406,"byte_end":3409,"line_start":136,"line_end":136,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"::\").map(|_| Cons),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:136:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"::\").map(|_| Cons),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3442,"byte_end":3445,"line_start":137,"line_end":137,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"<=\").map(|_| LTE),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:137:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m137\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"<=\").map(|_| LTE),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3476,"byte_end":3479,"line_start":138,"line_end":138,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"<\").map(|_| LT),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:138:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m138\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"<\").map(|_| LT),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3510,"byte_end":3513,"line_start":139,"line_end":139,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\">=\").map(|_| GTE),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:139:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\">=\").map(|_| GTE),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3544,"byte_end":3547,"line_start":140,"line_end":140,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\">\").map(|_| GT),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:140:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\">\").map(|_| GT),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3578,"byte_end":3581,"line_start":141,"line_end":141,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"++\").map(|_| Concat),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:141:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"++\").map(|_| Concat),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3615,"byte_end":3618,"line_start":142,"line_end":142,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"+\").map(|_| Plus),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:142:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"+\").map(|_| Plus),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3650,"byte_end":3653,"line_start":143,"line_end":143,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"-\").map(|_| Minus),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:143:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"-\").map(|_| Minus),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3686,"byte_end":3689,"line_start":144,"line_end":144,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"*\").map(|_| Times),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:144:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"*\").map(|_| Times),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3722,"byte_end":3725,"line_start":145,"line_end":145,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"/\").map(|_| Divide),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:145:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"/\").map(|_| Divide),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3759,"byte_end":3762,"line_start":146,"line_end":146,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"%\").map(|_| Mod),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:146:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"%\").map(|_| Mod),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":3793,"byte_end":3796,"line_start":147,"line_end":147,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"^\").map(|_| Power),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:147:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"^\").map(|_| Power),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":4908,"byte_end":4919,"line_start":186,"line_end":186,"column_start":15,"column_end":26,"is_primary":true,"text":[{"text":"        lhs = Expr::BinOp {","highlight_start":15,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `BinOp` implemented for `source::Expr<'_>`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/parse/expression.rs","byte_start":4908,"byte_end":4919,"line_start":186,"line_end":186,"column_start":15,"column_end":26,"is_primary":true,"text":[{"text":"        lhs = Expr::BinOp {","highlight_start":15,"highlight_end":26}],"label":null,"suggested_replacement":"<source::Expr<'_> as Example>::BinOp","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:186:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lhs = Expr::BinOp {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if there were a trait named `Example` with associated type `BinOp` implemented for `source::Expr<'_>`, you could use the fully-qualified path\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        lhs = \u001b[0m\u001b[0m\u001b[38;5;9mExpr::BinOp\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        lhs = \u001b[0m\u001b[0m\u001b[38;5;10m<source::Expr<'_> as Example>::BinOp\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `parse` found for fn item `fn({type error}) -> Result<({type error}, Expr<'_>), ...> {term::<'_>}` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5129,"byte_end":5134,"line_start":197,"line_end":197,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"    let (i, first) = term.parse(i)?;","highlight_start":27,"highlight_end":32}],"label":"method not found in `fn({type error}) -> Result<({type error}, Expr<'_>), ...> {term::<'_>}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `parse` found for fn item `fn({type error}) -> Result<({type error}, Expr<'_>), ...> {term::<'_>}` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:197:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, first) = term.parse(i)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `fn({type error}) -> Result<({type error}, Expr<'_>), ...> {term::<'_>}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5482,"byte_end":5508,"line_start":207,"line_end":208,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, name) = value_identifier","highlight_start":21,"highlight_end":37},{"text":"        .preceded_by(keyword(\"let\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":5508,"byte_end":5519,"line_start":208,"line_end":208,"column_start":10,"column_end":21,"is_primary":true,"text":[{"text":"        .preceded_by(keyword(\"let\"))","highlight_start":10,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:208:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m207\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, name) = value_identifier\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m _____________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .preceded_by(keyword(\"let\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5611,"byte_end":5631,"line_start":211,"line_end":212,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, value) = expression","highlight_start":22,"highlight_end":32},{"text":"        .terminated(symbol(\";\").context(\"semicolon\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":5631,"byte_end":5641,"line_start":212,"line_end":212,"column_start":10,"column_end":20,"is_primary":true,"text":[{"text":"        .terminated(symbol(\";\").context(\"semicolon\"))","highlight_start":10,"highlight_end":20}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:212:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, value) = expression\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .terminated(symbol(\";\").context(\"semicolon\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5654,"byte_end":5661,"line_start":212,"line_end":212,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"        .terminated(symbol(\";\").context(\"semicolon\"))","highlight_start":33,"highlight_end":40}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\nwhich is required by `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\n`&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:212:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .terminated(symbol(\";\").context(\"semicolon\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `parse` found for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5727,"byte_end":5732,"line_start":214,"line_end":214,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"    let (i, body) = expression.parse(i)?;","highlight_start":32,"highlight_end":37}],"label":"method not found in `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `parse` found for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:214:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, body) = expression.parse(i)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Bind` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5757,"byte_end":5761,"line_start":216,"line_end":216,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"    success(Expr::Bind(","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Bind` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Bind` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:216:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Expr::Bind(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Bind` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":5917,"byte_end":5943,"line_start":224,"line_end":225,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, name) = value_identifier","highlight_start":21,"highlight_end":37},{"text":"        .preceded_by(keyword(\"let\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":5943,"byte_end":5954,"line_start":225,"line_end":225,"column_start":10,"column_end":21,"is_primary":true,"text":[{"text":"        .preceded_by(keyword(\"let\"))","highlight_start":10,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:225:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, name) = value_identifier\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m _____________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m225\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .preceded_by(keyword(\"let\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6045,"byte_end":6065,"line_start":228,"line_end":229,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, value) = expression","highlight_start":22,"highlight_end":32},{"text":"        .terminated(symbol(\";\").context(\"semicolon\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":6065,"byte_end":6075,"line_start":229,"line_end":229,"column_start":10,"column_end":20,"is_primary":true,"text":[{"text":"        .terminated(symbol(\";\").context(\"semicolon\"))","highlight_start":10,"highlight_end":20}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:229:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, value) = expression\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .terminated(symbol(\";\").context(\"semicolon\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6088,"byte_end":6095,"line_start":229,"line_end":229,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"        .terminated(symbol(\";\").context(\"semicolon\"))","highlight_start":33,"highlight_end":40}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\nwhich is required by `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\n`&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:229:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .terminated(symbol(\";\").context(\"semicolon\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `parse` found for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6161,"byte_end":6166,"line_start":231,"line_end":231,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"    let (i, body) = expression.parse(i)?;","highlight_start":32,"highlight_end":37}],"label":"method not found in `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `parse` found for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:231:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, body) = expression.parse(i)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Let` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6191,"byte_end":6194,"line_start":233,"line_end":233,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"    success(Expr::Let(","highlight_start":19,"highlight_end":22}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Let` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Let` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:233:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Expr::Let(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Let` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `parse` found for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6449,"byte_end":6454,"line_start":242,"line_end":242,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"    let (i, body) = expression.parse(i)?;","highlight_start":32,"highlight_end":37}],"label":"method not found in `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `parse` found for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:242:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, body) = expression.parse(i)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Lambda` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6583,"byte_end":6589,"line_start":247,"line_end":247,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"        args.fold(Expr::Lambda(final_arg, Box::new(body)), |f, arg| {","highlight_start":25,"highlight_end":31}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Lambda` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Lambda` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:247:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        args.fold(Expr::Lambda(final_arg, Box::new(body)), |f, arg| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Lambda` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Lambda` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6647,"byte_end":6653,"line_start":248,"line_end":248,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"            Expr::Lambda(arg, Box::new(f))","highlight_start":19,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Lambda` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Lambda` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:248:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m248\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Lambda(arg, Box::new(f))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Lambda` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `If` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":6987,"byte_end":6989,"line_start":259,"line_end":259,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    success(Expr::If(","highlight_start":19,"highlight_end":21}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `If` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `If` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:259:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m259\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Expr::If(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `If` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn(&str) -> Result<({type error}, Pattern<'a>), Err<...>> {pattern}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7190,"byte_end":7200,"line_start":268,"line_end":268,"column_start":28,"column_end":38,"is_primary":true,"text":[{"text":"    let (i, pat) = pattern.terminated(symbol(\"->\")).parse(i)?;","highlight_start":28,"highlight_end":38}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn(&str) -> Result<({type error}, Pattern<'a>), Err<...>> {pattern}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:268:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, pat) = pattern.terminated(symbol(\"->\")).parse(i)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl nom::Parser<_, Output = (_, _), Error = _>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7266,"byte_end":7289,"line_start":270,"line_end":270,"column_start":5,"column_end":28,"is_primary":false,"text":[{"text":"    success((pat, body))(i)","highlight_start":5,"highlight_end":28}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":7266,"byte_end":7286,"line_start":270,"line_end":270,"column_start":5,"column_end":25,"is_primary":true,"text":[{"text":"    success((pat, body))(i)","highlight_start":5,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl nom::Parser<_, Output = (_, _), Error = _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:270:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success((pat, body))(i)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `When` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7591,"byte_end":7595,"line_start":279,"line_end":279,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"    success(Expr::When(Box::new(val), alternatives))(i)","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `When` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `When` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:279:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m279\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Expr::When(Box::new(val), alternatives))(i)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `When` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Ap` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7758,"byte_end":7760,"line_start":284,"line_end":284,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    success(Expr::Ap(","highlight_start":19,"highlight_end":21}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Ap` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Ap` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:284:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Expr::Ap(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Ap` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `External` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7785,"byte_end":7793,"line_start":285,"line_end":285,"column_start":24,"column_end":32,"is_primary":true,"text":[{"text":"        Box::new(Expr::External(\"crash\".to_owned())),","highlight_start":24,"highlight_end":32}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `External` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `External` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:285:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Box::new(Expr::External(\"crash\".to_owned())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `External` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `String` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7839,"byte_end":7845,"line_start":286,"line_end":286,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"        Box::new(Expr::String(msg)),","highlight_start":24,"highlight_end":30}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `String` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `String` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:286:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Box::new(Expr::String(msg)),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `String` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `External` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":7995,"byte_end":8003,"line_start":292,"line_end":292,"column_start":19,"column_end":27,"is_primary":true,"text":[{"text":"    success(Expr::External(name))(i)","highlight_start":19,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `External` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `External` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:292:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m292\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Expr::External(name))(i)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `External` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":8085,"byte_end":8105,"line_start":296,"line_end":297,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, first) = expression","highlight_start":22,"highlight_end":32},{"text":"        .preceded_by(symbol(\"(\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":8105,"byte_end":8116,"line_start":297,"line_end":297,"column_start":10,"column_end":21,"is_primary":true,"text":[{"text":"        .preceded_by(symbol(\"(\"))","highlight_start":10,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:297:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, first) = expression\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .preceded_by(symbol(\"(\"))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Tuple` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":8380,"byte_end":8385,"line_start":305,"line_end":305,"column_start":18,"column_end":23,"is_primary":true,"text":[{"text":"    Ok((i, Expr::Tuple(exprs)))","highlight_start":18,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Tuple` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Tuple` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:305:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m305\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Ok((i, Expr::Tuple(exprs)))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Tuple` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for struct `Choice<(..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ...)>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/expression.rs","byte_start":8447,"byte_end":8689,"line_start":309,"line_end":322,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    alt((","highlight_start":5,"highlight_end":10},{"text":"        if_expr,","highlight_start":1,"highlight_end":17},{"text":"        when_expr,","highlight_start":1,"highlight_end":19},{"text":"        lambda,","highlight_start":1,"highlight_end":16},{"text":"        crash_expr,","highlight_start":1,"highlight_end":20},{"text":"        extern_expr,","highlight_start":1,"highlight_end":21},{"text":"        operator_expression,","highlight_start":1,"highlight_end":29},{"text":"        let_from,","highlight_start":1,"highlight_end":18},{"text":"        let_in,","highlight_start":1,"highlight_end":16},{"text":"        term,","highlight_start":1,"highlight_end":14},{"text":"        tuple_expression,","highlight_start":1,"highlight_end":26},{"text":"        parens(expression),","highlight_start":1,"highlight_end":28},{"text":"    ))","highlight_start":1,"highlight_end":7},{"text":"    .context(\"expression\")","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/expression.rs","byte_start":8689,"byte_end":8696,"line_start":322,"line_end":322,"column_start":6,"column_end":13,"is_primary":true,"text":[{"text":"    .context(\"expression\")","highlight_start":6,"highlight_end":13}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs","byte_start":3655,"byte_end":3675,"line_start":113,"line_end":113,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Choice<T> {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `_: Parser<_, _, _>` or `_: ParserExt<_, _, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom::internal::Parser<_, _, _>`\nwhich is required by `Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom_supreme::ParserExt<_, _, _>`\n`&Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom::internal::Parser<_, _, _>`\nwhich is required by `&Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom_supreme::ParserExt<_, _, _>`\n`&mut Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for struct `Choice<(..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ...)>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/expression.rs:322:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    alt((\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if_expr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m311\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        when_expr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        lambda,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m321\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .context(\"expression\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/mckahz/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nom-8.0.0/src/branch/mod.rs:113:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct Choice<T> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: Parser<_, _, _>` or `_: ParserExt<_, _, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut Choice<(fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {if_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {when_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {lambda::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {crash_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {extern_expr::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {operator_expression::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_from::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_in::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::term::<'_>}, fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {tuple_expression::<'_>}, impl FnMut({type error}) -> std::result::Result<({type error}, _), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>)>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `preceded_by` exists for fn item `fn(&str) -> Result<({type error}, Pattern<'a>), Err<...>> {pattern}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/pattern.rs","byte_start":117,"byte_end":134,"line_start":6,"line_end":7,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, first) = pattern","highlight_start":22,"highlight_end":29},{"text":"        .preceded_by(symbol(\"(\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/pattern.rs","byte_start":134,"byte_end":145,"line_start":7,"line_end":7,"column_start":10,"column_end":21,"is_primary":true,"text":[{"text":"        .preceded_by(symbol(\"(\"))","highlight_start":10,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `preceded_by` exists for fn item `fn(&str) -> Result<({type error}, Pattern<'a>), Err<...>> {pattern}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/pattern.rs:7:10\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, first) = pattern\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .preceded_by(symbol(\"(\"))\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m          `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m          which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m          `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m          which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m          `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m          which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/pattern.rs","byte_start":525,"byte_end":528,"line_start":21,"line_end":21,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        symbol(\"_\").map(|_| Pattern::Wildcard),","highlight_start":21,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/pattern.rs:21:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"_\").map(|_| Pattern::Wildcard),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m           which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m           `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m           which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m           `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/pattern.rs","byte_start":574,"byte_end":577,"line_start":22,"line_end":22,"column_start":22,"column_end":25,"is_primary":true,"text":[{"text":"        symbol(\"[]\").map(|_| Pattern::EmptyList),","highlight_start":22,"highlight_end":25}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/pattern.rs:22:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        symbol(\"[]\").map(|_| Pattern::EmptyList),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m           which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m           `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m           which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m           `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/pattern.rs","byte_start":676,"byte_end":679,"line_start":25,"line_end":25,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"        value_identifier.map(|ident| Pattern::Identifier(ident)),","highlight_start":26,"highlight_end":29}],"label":"`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/pattern.rs:25:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        value_identifier.map(|ident| Pattern::Identifier(ident)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `Choice<(fn({type error}) -> ... {value_identifier::<'_>}, ...)>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":153,"byte_end":196,"line_start":5,"line_end":5,"column_start":5,"column_end":48,"is_primary":false,"text":[{"text":"    alt((value_identifier, type_identifier))(i)","highlight_start":5,"highlight_end":48}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/statement.rs","byte_start":153,"byte_end":193,"line_start":5,"line_end":5,"column_start":5,"column_end":45,"is_primary":true,"text":[{"text":"    alt((value_identifier, type_identifier))(i)","highlight_start":5,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-16272288115891109363.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `Choice<(fn({type error}) -> ... {value_identifier::<'_>}, ...)>`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    alt((value_identifier, type_identifier))(i)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-16272288115891109363.txt'\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {string_literal::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":1400,"byte_end":1436,"line_start":44,"line_end":45,"column_start":25,"column_end":10,"is_primary":false,"text":[{"text":"    let (i, type_def) = expression::string_literal","highlight_start":25,"highlight_end":51},{"text":"        .preceded_by(keyword(\"extern\"))","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/statement.rs","byte_start":1436,"byte_end":1447,"line_start":45,"line_end":45,"column_start":10,"column_end":21,"is_primary":true,"text":[{"text":"        .preceded_by(keyword(\"extern\"))","highlight_start":10,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `preceded_by` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {string_literal::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:45:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let (i, type_def) = expression::string_literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m _________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .preceded_by(keyword(\"extern\"))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {string_literal::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `Choice<(fn(&str) -> Result<(..., ...), ...> {internal_type_def}, ...)>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":1659,"byte_end":1705,"line_start":54,"line_end":54,"column_start":5,"column_end":51,"is_primary":false,"text":[{"text":"    alt((internal_type_def, external_type_def))(i)","highlight_start":5,"highlight_end":51}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/statement.rs","byte_start":1659,"byte_end":1702,"line_start":54,"line_end":54,"column_start":5,"column_end":48,"is_primary":true,"text":[{"text":"    alt((internal_type_def, external_type_def))(i)","highlight_start":5,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-16337698871686606268.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `Choice<(fn(&str) -> Result<(..., ...), ...> {internal_type_def}, ...)>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:54:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    alt((internal_type_def, external_type_def))(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-16337698871686606268.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":1795,"byte_end":1805,"line_start":58,"line_end":58,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":"    let (i, name) = value_identifier.terminated(symbol(\":\")).parse(i)?;","highlight_start":38,"highlight_end":48}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:58:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, name) = value_identifier.terminated(symbol(\":\")).parse(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn(&str) -> Result<({type error}, Type<'a>), Err<...>> {tipe}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":1861,"byte_end":1871,"line_start":59,"line_end":59,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":"    let (i, tipe) = tipe::tipe.terminated(symbol(\";\")).parse(i)?;","highlight_start":32,"highlight_end":42}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn(&str) -> Result<({type error}, Type<'a>), Err<...>> {tipe}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:59:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, tipe) = tipe::tipe.terminated(symbol(\";\")).parse(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Type<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::tipe::tipe}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for opaque type `impl Parser<&str, Output = Vec<...>, Error = ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2082,"byte_end":2092,"line_start":66,"line_end":66,"column_start":47,"column_end":57,"is_primary":true,"text":[{"text":"    let (i, params) = many0(pattern::pattern).terminated(symbol(\"=\")).parse(i)?;","highlight_start":47,"highlight_end":57}],"label":"method cannot be called on `impl Parser<&str, Output = Vec<...>, Error = ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom::internal::Parser<_, _, _>`\nwhich is required by `impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom_supreme::ParserExt<_, _, _>`\n`&impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom::internal::Parser<_, _, _>`\nwhich is required by `&impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom_supreme::ParserExt<_, _, _>`\n`&mut impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for opaque type `impl Parser<&str, Output = Vec<...>, Error = ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:66:47\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, params) = many0(pattern::pattern).terminated(symbol(\"=\")).parse(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called on `impl Parser<&str, Output = Vec<...>, Error = ...>` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut impl nom::Parser<&str, Output = Vec<<for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Output>, Error = <for<'a> fn(&'a str) -> std::result::Result<({type error}, source::Pattern<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::pattern::pattern} as nom::Parser<&str>>::Error>: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2149,"byte_end":2159,"line_start":68,"line_end":68,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":"    let (i, body) = expression.terminated(symbol(\";\")).parse(i)?;","highlight_start":32,"highlight_end":42}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `terminated` exists for fn item `fn({type error}) -> Result<(..., ...), ...> {expression::<'_>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:68:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, body) = expression.terminated(symbol(\";\")).parse(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, source::Expr<'_>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::expression::expression::<'_>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Lambda` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2412,"byte_end":2418,"line_start":77,"line_end":77,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"            .fold(Expr::Lambda(last_param, Box::new(body)), |f, arg| {","highlight_start":25,"highlight_end":31}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Lambda` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Lambda` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:77:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .fold(Expr::Lambda(last_param, Box::new(body)), |f, arg| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Lambda` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Lambda` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2481,"byte_end":2487,"line_start":78,"line_end":78,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"                Expr::Lambda(arg, Box::new(f))","highlight_start":23,"highlight_end":29}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Lambda` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Lambda` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:78:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Expr::Lambda(arg, Box::new(f))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Lambda` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn(&str) -> Result<({type error}, Statement<'a>), ...> {let_value}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2701,"byte_end":2708,"line_start":89,"line_end":89,"column_start":23,"column_end":30,"is_primary":true,"text":[{"text":"            let_value.context(\"let value\"),","highlight_start":23,"highlight_end":30}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn(&str) -> Result<({type error}, Statement<'a>), ...> {let_value}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:89:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let_value.context(\"let value\"),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_value}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn(&str) -> Result<({type error}, Statement<'a>), ...> {let_signature}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2749,"byte_end":2756,"line_start":90,"line_end":90,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"            let_signature.context(\"type signature\"),","highlight_start":27,"highlight_end":34}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn(&str) -> Result<({type error}, Statement<'a>), ...> {let_signature}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:90:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let_signature.context(\"type signature\"),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_signature}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn(&str) -> Result<({type error}, Statement<'a>), Err<...>> {let_type}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2797,"byte_end":2804,"line_start":91,"line_end":91,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"            let_type.context(\"type definition\"),","highlight_start":22,"highlight_end":29}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn(&str) -> Result<({type error}, Statement<'a>), Err<...>> {let_type}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:91:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let_type.context(\"type definition\"),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {let_type}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn(&str) -> Result<({type error}, ...), ...> {import_statement}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/statement.rs","byte_start":2950,"byte_end":2957,"line_start":99,"line_end":99,"column_start":26,"column_end":33,"is_primary":true,"text":[{"text":"        import_statement.context(\"import statement\"),","highlight_start":26,"highlight_end":33}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn(&str) -> Result<({type error}, ...), ...> {import_statement}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/statement.rs:99:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        import_statement.context(\"import statement\"),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {import_statement}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":72,"byte_end":75,"line_start":4,"line_end":4,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"    symbol(\"()\").map(|_| Type::Unit).parse(i)","highlight_start":18,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\nwhich is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\n`impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\nwhich is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `map` exists for opaque type `impl FnMut({type error}) -> Result<({type error}, {type error}), ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:4:18\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    symbol(\"()\").map(|_| Type::Unit).parse(i)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m          `<&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> as FnOnce<(_,)>>::Output = std::result::Result<(_, _), nom::Err<_>>`\u001b[0m\n\u001b[0m          which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m          `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: FnMut<(_,)>`\u001b[0m\n\u001b[0m          which is required by `&impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: nom::Parser<_>`\u001b[0m\n\u001b[0m          `impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\u001b[0m          which is required by `&mut impl FnMut({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>>: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl nom::Parser<_, Output = source::Type<'_>, Error = _>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":574,"byte_end":604,"line_start":22,"line_end":22,"column_start":5,"column_end":35,"is_primary":false,"text":[{"text":"    success(Type::Tuple(types))(i)","highlight_start":5,"highlight_end":35}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":574,"byte_end":601,"line_start":22,"line_end":22,"column_start":5,"column_end":32,"is_primary":true,"text":[{"text":"    success(Type::Tuple(types))(i)","highlight_start":5,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl nom::Parser<_, Output = source::Type<'_>, Error = _>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:22:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Type::Tuple(types))(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":683,"byte_end":686,"line_start":27,"line_end":27,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"        type_identifier.map(Type::Identifier),","highlight_start":25,"highlight_end":28}],"label":"`fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: `fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:27:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        type_identifier.map(Type::Identifier),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`fn({type error}) -> Result<(..., ...), ...> {type_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, {type error}), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::type_identifier::<'_>}: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":731,"byte_end":734,"line_start":28,"line_end":28,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"        value_identifier.map(Type::Identifier),","highlight_start":26,"highlight_end":29}],"label":"`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\nwhich is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: `fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:28:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        value_identifier.map(Type::Identifier),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`fn({type error}) -> Result<(..., ...), ...> {value_identifier::<'_>}` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut fn({type error}) -> std::result::Result<({type error}, String), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse::value_identifier::<'_>}: Iterator`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `Choice<(fn({type error}) -> ... {type_identifier::<'_>}, ...)>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":911,"byte_end":954,"line_start":37,"line_end":37,"column_start":21,"column_end":64,"is_primary":false,"text":[{"text":"    let (i, name) = alt((type_identifier, value_identifier))(i)?;","highlight_start":21,"highlight_end":64}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":911,"byte_end":951,"line_start":37,"line_end":37,"column_start":21,"column_end":61,"is_primary":true,"text":[{"text":"    let (i, name) = alt((type_identifier, value_identifier))(i)?;","highlight_start":21,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-748500719683690037.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `Choice<(fn({type error}) -> ... {type_identifier::<'_>}, ...)>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:37:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, name) = alt((type_identifier, value_identifier))(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-748500719683690037.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl Parser<&str, Output = Vec<...>, Error = ...>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":980,"byte_end":996,"line_start":38,"line_end":38,"column_start":24,"column_end":40,"is_primary":false,"text":[{"text":"    let (i, factors) = many0(factor)(i)?;","highlight_start":24,"highlight_end":40}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":980,"byte_end":993,"line_start":38,"line_end":38,"column_start":24,"column_end":37,"is_primary":true,"text":[{"text":"    let (i, factors) = many0(factor)(i)?;","highlight_start":24,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7776216046262927924.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl Parser<&str, Output = Vec<...>, Error = ...>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:38:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, factors) = many0(factor)(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7776216046262927924.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl nom::Parser<_, Output = source::Type<'_>, Error = _>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":1035,"byte_end":1069,"line_start":40,"line_end":40,"column_start":9,"column_end":43,"is_primary":false,"text":[{"text":"        success(Type::Identifier(name))(i)","highlight_start":9,"highlight_end":43}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":1035,"byte_end":1066,"line_start":40,"line_end":40,"column_start":9,"column_end":40,"is_primary":true,"text":[{"text":"        success(Type::Identifier(name))(i)","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl nom::Parser<_, Output = source::Type<'_>, Error = _>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:40:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        success(Type::Identifier(name))(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl nom::Parser<_, Output = source::Type<'_>, Error = _>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":1091,"byte_end":1128,"line_start":42,"line_end":42,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        success(Type::Cons(name, factors))(i)","highlight_start":9,"highlight_end":46}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":1091,"byte_end":1125,"line_start":42,"line_end":42,"column_start":9,"column_end":43,"is_primary":true,"text":[{"text":"        success(Type::Cons(name, factors))(i)","highlight_start":9,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl nom::Parser<_, Output = source::Type<'_>, Error = _>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:42:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        success(Type::Cons(name, factors))(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `Choice<(fn(&str) -> Result<(..., ...), ...> {constructor}, ...)>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":1181,"byte_end":1210,"line_start":47,"line_end":47,"column_start":5,"column_end":34,"is_primary":false,"text":[{"text":"    alt((constructor, factor))(i)","highlight_start":5,"highlight_end":34}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":1181,"byte_end":1207,"line_start":47,"line_end":47,"column_start":5,"column_end":31,"is_primary":true,"text":[{"text":"    alt((constructor, factor))(i)","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-6540811057291387243.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `Choice<(fn(&str) -> Result<(..., ...), ...> {constructor}, ...)>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:47:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    alt((constructor, factor))(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-6540811057291387243.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `Choice<(fn(&str) -> Result<({type error}, ...), ...> {function}, ...)>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/tipe.rs","byte_start":1530,"byte_end":1554,"line_start":58,"line_end":58,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    alt((function, term))(i)","highlight_start":5,"highlight_end":29}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/tipe.rs","byte_start":1530,"byte_end":1551,"line_start":58,"line_end":58,"column_start":5,"column_end":26,"is_primary":true,"text":[{"text":"    alt((function, term))(i)","highlight_start":5,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-2844023020829426787.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `Choice<(fn(&str) -> Result<({type error}, ...), ...> {function}, ...)>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/tipe.rs:58:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    alt((function, term))(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-2844023020829426787.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":1634,"byte_end":1750,"line_start":57,"line_end":59,"column_start":29,"column_end":15,"is_primary":false,"text":[{"text":"        let (i, mut rest) = many0(satisfy(|c| {","highlight_start":29,"highlight_end":48},{"text":"            (c.is_alphabetic() && c.is_lowercase()) || c == '_' || c.is_numeric()","highlight_start":1,"highlight_end":82},{"text":"        }))(i)?;","highlight_start":1,"highlight_end":15}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/mod.rs","byte_start":1634,"byte_end":1747,"line_start":57,"line_end":59,"column_start":29,"column_end":12,"is_primary":true,"text":[{"text":"        let (i, mut rest) = many0(satisfy(|c| {","highlight_start":29,"highlight_end":48},{"text":"            (c.is_alphabetic() && c.is_lowercase()) || c == '_' || c.is_numeric()","highlight_start":1,"highlight_end":82},{"text":"        }))(i)?;","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-10780693082617357165.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:57:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m        let (i, mut rest) = many0(satisfy(|c| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m _____________________________^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m_____________________________|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            (c.is_alphabetic() && c.is_lowercase()) || c == '_' || c.is_numeric()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }))(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m___________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|___________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-10780693082617357165.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":1780,"byte_end":1811,"line_start":60,"line_end":60,"column_start":28,"column_end":59,"is_primary":false,"text":[{"text":"        let (i, mut end) = many0(satisfy(|c| c == '?'))(i)?;","highlight_start":28,"highlight_end":59}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/mod.rs","byte_start":1780,"byte_end":1808,"line_start":60,"line_end":60,"column_start":28,"column_end":56,"is_primary":true,"text":[{"text":"        let (i, mut end) = many0(satisfy(|c| c == '?'))(i)?;","highlight_start":28,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-13758196298569511210.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:60:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let (i, mut end) = many0(satisfy(|c| c == '?'))(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-13758196298569511210.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn() -> impl Parser<_, Output = _, Error = _> {fail::<_, _, _>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":2234,"byte_end":2241,"line_start":76,"line_end":76,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"        fail.context(\"non keyword identifier\").parse(i)","highlight_start":14,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom_supreme::ParserExt<_, _, _>`\n`&fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn() -> impl Parser<_, Output = _, Error = _> {fail::<_, _, _>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:76:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        fail.context(\"non keyword identifier\").parse(i)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m           `&mut fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m           which is required by `&mut fn() -> impl nom::Parser<_, Output = _, Error = _> {fail::<_, _, _>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":2586,"byte_end":2644,"line_start":88,"line_end":88,"column_start":25,"column_end":83,"is_primary":false,"text":[{"text":"    let (i, mut rest) = many0(satisfy(|c| c.is_alphabetic() || c.is_numeric()))(i)?;","highlight_start":25,"highlight_end":83}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/mod.rs","byte_start":2586,"byte_end":2641,"line_start":88,"line_end":88,"column_start":25,"column_end":80,"is_primary":true,"text":[{"text":"    let (i, mut rest) = many0(satisfy(|c| c.is_alphabetic() || c.is_numeric()))(i)?;","highlight_start":25,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-15271906337710276954.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:88:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, mut rest) = many0(satisfy(|c| c.is_alphabetic() || c.is_numeric()))(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-15271906337710276954.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":2670,"byte_end":2701,"line_start":89,"line_end":89,"column_start":24,"column_end":55,"is_primary":false,"text":[{"text":"    let (i, mut end) = many0(satisfy(|c| c == '?'))(i)?;","highlight_start":24,"highlight_end":55}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/mod.rs","byte_start":2670,"byte_end":2698,"line_start":89,"line_end":89,"column_start":24,"column_end":52,"is_primary":true,"text":[{"text":"    let (i, mut end) = many0(satisfy(|c| c == '?'))(i)?;","highlight_start":24,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7455392754182256221.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl Parser<_, Output = Vec<<... as Parser<_>>::Output>, Error = ...>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:89:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, mut end) = many0(satisfy(|c| c == '?'))(i)?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/mckahz/projects/pac/target/debug/deps/language-0dc04b9c15d773c3.long-type-7455392754182256221.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn(_) -> Result<(_, _), Err<_>> {alphanumeric1::<_, _>}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":3095,"byte_end":3102,"line_start":104,"line_end":104,"column_start":70,"column_end":77,"is_primary":true,"text":[{"text":"    let (i, module_name) = preceded(keyword(\"module\"), alphanumeric1.context(\"module name\"))(i)?;","highlight_start":70,"highlight_end":77}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom::internal::Parser<_, _, _>`\nwhich is required by `fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom_supreme::ParserExt<_, _, _>`\n`&fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom_supreme::ParserExt<_, _, _>`\n`&mut fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn(_) -> Result<(_, _), Err<_>> {alphanumeric1::<_, _>}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:104:70\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, module_name) = preceded(keyword(\"module\"), alphanumeric1.context(\"module name\"))(i)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut fn(_) -> std::result::Result<(_, _), nom::Err<_>> {nom::character::complete::alphanumeric1::<_, _>}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `context` exists for fn item `fn(&str) -> Result<({type error}, ...), ...> {parse_statement}`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":3398,"byte_end":3405,"line_start":114,"line_end":114,"column_start":64,"column_end":71,"is_primary":true,"text":[{"text":"    let (i, statements) = many_till(statement::parse_statement.context(\"statement\"), eof)","highlight_start":64,"highlight_end":71}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom::internal::Parser<_, _, _>`\nwhich is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom_supreme::ParserExt<_, _, _>`\n`&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom::internal::Parser<_, _, _>`\nwhich is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom_supreme::ParserExt<_, _, _>`\n`&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom::internal::Parser<_, _, _>`\nwhich is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom_supreme::ParserExt<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `context` exists for fn item `fn(&str) -> Result<({type error}, ...), ...> {parse_statement}`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:114:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (i, statements) = many_till(statement::parse_statement.context(\"statement\"), eof)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\u001b[0m            `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom::internal::Parser<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `&mut for<'a> fn(&'a str) -> std::result::Result<({type error}, Statement<'a>), nom::Err<GenericErrorTree<{type error}, &'static str, &'static str, Box<(dyn std::error::Error + Send + Sync + 'static)>>>> {parse_statement}: nom_supreme::ParserExt<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected function, found `impl nom::Parser<_, Output = source::Module<'_>, Error = _>`","code":{"code":"E0618","explanation":"Attempted to call something which isn't a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, tuple struct or tuple variant,\n            // found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, tuple struct or tuple variant, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n"},"level":"error","spans":[{"file_name":"src/parse/mod.rs","byte_start":3991,"byte_end":4222,"line_start":132,"line_end":140,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    success(Module {","highlight_start":5,"highlight_end":21},{"text":"        name: module_name.to_owned(),","highlight_start":1,"highlight_end":38},{"text":"        imports,","highlight_start":1,"highlight_end":17},{"text":"        type_defs,","highlight_start":1,"highlight_end":19},{"text":"        signatures,","highlight_start":1,"highlight_end":20},{"text":"        interface,","highlight_start":1,"highlight_end":19},{"text":"        // TODO: properly parse the imports, then the definitions in a module","highlight_start":1,"highlight_end":78},{"text":"        defs,","highlight_start":1,"highlight_end":14},{"text":"    })(i)","highlight_start":1,"highlight_end":10}],"label":"call expression requires function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parse/mod.rs","byte_start":3991,"byte_end":4219,"line_start":132,"line_end":140,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    success(Module {","highlight_start":5,"highlight_end":21},{"text":"        name: module_name.to_owned(),","highlight_start":1,"highlight_end":38},{"text":"        imports,","highlight_start":1,"highlight_end":17},{"text":"        type_defs,","highlight_start":1,"highlight_end":19},{"text":"        signatures,","highlight_start":1,"highlight_end":20},{"text":"        interface,","highlight_start":1,"highlight_end":19},{"text":"        // TODO: properly parse the imports, then the definitions in a module","highlight_start":1,"highlight_end":78},{"text":"        defs,","highlight_start":1,"highlight_end":14},{"text":"    })(i)","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0618]\u001b[0m\u001b[0m\u001b[1m: expected function, found `impl nom::Parser<_, Output = source::Module<'_>, Error = _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/parse/mod.rs:132:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m132\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    success(Module {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        name: module_name.to_owned(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        imports,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        type_defs,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        defs,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    })(i)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcall expression requires function\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|______|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Identifier` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3379,"byte_end":3389,"line_start":116,"line_end":116,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"            Expr::Identifier(i) => i.to_owned(),","highlight_start":19,"highlight_end":29}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Identifier` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Identifier` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:116:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Identifier(i) => i.to_owned(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Identifier` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3422,"byte_end":3433,"line_start":117,"line_end":117,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"            Expr::BinOp { op, lhs, rhs } => {","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `BinOp` implemented for `source::Expr<'_>`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/report/pretty.rs","byte_start":3422,"byte_end":3433,"line_start":117,"line_end":117,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"            Expr::BinOp { op, lhs, rhs } => {","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":"<source::Expr<'_> as Example>::BinOp","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:117:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::BinOp { op, lhs, rhs } => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if there were a trait named `Example` with associated type `BinOp` implemented for `source::Expr<'_>`, you could use the fully-qualified path\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;9mExpr::BinOp\u001b[0m\u001b[0m { op, lhs, rhs } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10m<source::Expr<'_> as Example>::BinOp\u001b[0m\u001b[0m { op, lhs, rhs } => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Nat` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3722,"byte_end":3725,"line_start":126,"line_end":126,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"            Expr::Nat(n) => n.to_string(),","highlight_start":19,"highlight_end":22}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Nat` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Nat` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:126:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m126\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Nat(n) => n.to_string(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Nat` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Int` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3765,"byte_end":3768,"line_start":127,"line_end":127,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"            Expr::Int(i) => i.to_string(),","highlight_start":19,"highlight_end":22}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Int` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Int` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:127:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Int(i) => i.to_string(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Int` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Float` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3808,"byte_end":3813,"line_start":128,"line_end":128,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"            Expr::Float(x) => x.to_string(),","highlight_start":19,"highlight_end":24}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Float` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Float` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:128:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Float(x) => x.to_string(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Float` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `String` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3853,"byte_end":3859,"line_start":129,"line_end":129,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"            Expr::String(s) => \"\\\"\".to_owned() + s + \"\\\"\",","highlight_start":19,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `String` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `String` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:129:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::String(s) => \"\\\"\".to_owned() + s + \"\\\"\",\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `String` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Record` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":3912,"byte_end":3918,"line_start":130,"line_end":130,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"            Expr::Record(fields) => {","highlight_start":19,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Record` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Record` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:130:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m130\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Record(fields) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Record` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Access` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":4267,"byte_end":4273,"line_start":139,"line_end":139,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"            Expr::Access(module, member) => module.to_owned() + \".\" + &member,","highlight_start":19,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Access` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Access` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:139:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Access(module, member) => module.to_owned() + \".\" + &member,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Access` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `List` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":4346,"byte_end":4350,"line_start":140,"line_end":140,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            Expr::List(xs) => {","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `List` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `List` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:140:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::List(xs) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `List` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Ap` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":4645,"byte_end":4647,"line_start":149,"line_end":149,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"            Expr::Ap(f, xs) => \"(\".to_string() + &f.pretty_print() + \" \" + &xs.pretty_print() + \")\",","highlight_start":19,"highlight_end":21}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Ap` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Ap` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:149:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Ap(f, xs) => \"(\".to_string() + &f.pretty_print() + \" \" + &xs.pretty_print() + \")\",\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Ap` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Lambda` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":4746,"byte_end":4752,"line_start":150,"line_end":150,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"            Expr::Lambda(arg, body) => {","highlight_start":19,"highlight_end":25}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Lambda` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Lambda` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:150:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Lambda(arg, body) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Lambda` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `When` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":4894,"byte_end":4898,"line_start":153,"line_end":153,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            Expr::When(expr, branches) => {","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `When` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `When` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:153:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::When(expr, branches) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `When` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Unit` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":5518,"byte_end":5522,"line_start":168,"line_end":168,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            Expr::Unit => \"()\".to_string(),","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Unit` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Unit` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:168:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Unit => \"()\".to_string(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Unit` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `If` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":5562,"byte_end":5564,"line_start":169,"line_end":169,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"            Expr::If(cond, then_branch, else_branch) => {","highlight_start":19,"highlight_end":21}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `If` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `If` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:169:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m169\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::If(cond, then_branch, else_branch) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `If` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Bool` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":5900,"byte_end":5904,"line_start":178,"line_end":178,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            Expr::Bool(bool) => bool.to_string(),","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Bool` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Bool` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:178:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Bool(bool) => bool.to_string(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Bool` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `External` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":5950,"byte_end":5958,"line_start":179,"line_end":179,"column_start":19,"column_end":27,"is_primary":true,"text":[{"text":"            Expr::External(name) => \"@\".to_string() + name,","highlight_start":19,"highlight_end":27}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `External` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `External` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:179:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::External(name) => \"@\".to_string() + name,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `External` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Let` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":6010,"byte_end":6013,"line_start":180,"line_end":180,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"            Expr::Let(pattern, def, body) => {","highlight_start":19,"highlight_end":22}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Let` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Let` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:180:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Let(pattern, def, body) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Let` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Bind` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":6292,"byte_end":6296,"line_start":188,"line_end":188,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            Expr::Bind(pattern, def, body) => {","highlight_start":19,"highlight_end":23}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Bind` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Bind` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:188:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Bind(pattern, def, body) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Bind` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Constructor` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":6576,"byte_end":6587,"line_start":196,"line_end":196,"column_start":19,"column_end":30,"is_primary":true,"text":[{"text":"            Expr::Constructor(cons) => cons.to_owned(),","highlight_start":19,"highlight_end":30}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Constructor` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Constructor` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:196:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m196\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Constructor(cons) => cons.to_owned(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Constructor` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no associated item named `Tuple` found for struct `source::Expr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/report/pretty.rs","byte_start":6632,"byte_end":6637,"line_start":197,"line_end":197,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"            Expr::Tuple(exprs) => {","highlight_start":19,"highlight_end":24}],"label":"associated item not found in `Expr<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast/source.rs","byte_start":1213,"byte_end":1232,"line_start":56,"line_end":56,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Expr<'a> {","highlight_start":1,"highlight_end":20}],"label":"associated item `Tuple` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no associated item named `Tuple` found for struct `source::Expr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/report/pretty.rs:197:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expr::Tuple(exprs) => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated item not found in `Expr<'_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/ast/source.rs:56:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Expr<'a> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12massociated item `Tuple` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 178 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 178 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0106, E0107, E0223, E0271, E0277, E0412, E0425, E0432, E0599...","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0106, E0107, E0223, E0271, E0277, E0412, E0425, E0432, E0599...\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0106`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0106`.\u001b[0m\n"}
